! $Id: ESMF_FieldSetCo.cppF90,v 1.16.2.1 2010/02/05 19:56:10 svasquez Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2010, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_FieldSetCo.F90"
!==============================================================================
!
!     ESMF FieldSetCo module
module ESMF_FieldSetCoMod
!
!==============================================================================
!
! This file contains the FieldSet() methods.
!
!------------------------------------------------------------------------------
! INCLUDES
! < ignore blank lines below.  they are created by the files which
!   define various macros. >
^include "ESMF.h"
#include "ESMF_TypeKindRankMacros.hcppF90"

!------------------------------------------------------------------------------
! !USES:
  use ESMF_UtilTypesMod
  use ESMF_BaseMod
  use ESMF_LogErrMod
  use ESMF_LocalArrayMod
  use ESMF_DistGridMod
  use ESMF_StaggerLocMod
  use ESMF_GridMod
  use ESMF_MeshMod
  use ESMF_LocStreamMod
  use ESMF_GeomBaseMod
  use ESMF_ArrayMod
  use ESMF_ArrayCreateMod
  use ESMF_InitMacrosMod

  use ESMF_FieldMod

  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! !PUBLIC MEMBER FUNCTIONS:

  public ESMF_FieldSetCommit
 
!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
  character(*), parameter, private :: version = &
    '$Id: ESMF_FieldSetCo.cppF90,v 1.16.2.1 2010/02/05 19:56:10 svasquez Exp $'

!==============================================================================
! 
! INTERFACE BLOCKS
!
!==============================================================================


!------------------------------------------------------------------------------
!BOPI 
! !IROUTINE: ESMF_FieldSetCommit - Finishes a Field started with FieldCreateEmpty
!
! !INTERFACE:
  interface ESMF_FieldSetCommit

! !PRIVATE MEMBER FUNCTIONS:
!
    TypeKindRankInterfaceMacro(FieldSetCommitGrid)
    TypeKindRankInterfaceMacro(FieldSetCommitGridPtr)
    TypeKindRankInterfaceMacro(FieldSetCommitLS)
    TypeKindRankInterfaceMacro(FieldSetCommitLSPtr)
    TypeKindRankInterfaceMacro(FieldSetCommitMesh)
    TypeKindRankInterfaceMacro(FieldSetCommitMeshPtr)
    TypeKindRankInterfaceMacro(FieldSetCommitGB)
    TypeKindRankInterfaceMacro(FieldSetCommitGBPtr)

! !DESCRIPTION:
!   This interface finishes a {\tt ESMF\_Field} started with FieldCreateEmpty
!   These methods all take {\tt ESMF\_Grid} and Fortran data array or pointer as input to
!   fill in the {\tt ESMF\_Field} internals. 
  end interface
!EOPI
!------------------------------------------------------------------------------


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#define FieldSetCommitGridDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from Grid started with FieldCreateEmpty @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldSetCommit() @\
! subroutine ESMF_FieldSetCommitGrid<rank><type><kind>(field, grid, & @\
!   farray, indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & @\
!   ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Field),      intent(inout)        :: field @\
!   type(ESMF_Grid),       intent(in)           :: grid @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), target  :: farray @\
!   type(ESMF_IndexFlag),  intent(in)           :: indexflag @\
!   type(ESMF_CopyFlag),   intent(in), optional :: copyflag @\
!   type(ESMF_STAGGERLOC), intent(in), optional :: staggerloc @\
!   integer,               intent(in), optional :: gridToFieldMap(:) @\
!   integer,               intent(in), optional :: ungriddedLBound(:) @\
!   integer,               intent(in), optional :: ungriddedUBound(:) @\
!   integer,               intent(in), optional :: maxHaloLWidth(:) @\
!   integer,               intent(in), optional :: maxHaloUWidth(:) @\
!   integer,               intent(inout), optional :: rc @\
! @\
! !DESCRIPTION: @\
! This call completes an {\tt ESMF\_Field} allocated with the @\
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and @\
! associated documentation using this method see Section  @\
! \ref{sec:field:usage:create_empty_setcommit}. @\
! @\
! The fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating @\
! the retrieved data pointer is not allowed. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [field]  @\
!       The {\tt ESMF\_Field} object to be completed and @\
!       committed in this call. The {\tt field} will have the same dimension @\
!       (dimCount) as the rank of the {\tt farray}.  @\
! \item [grid]  @\
!       The {\tt ESMF\_Grid} object to finish the Field. @\
! \item [farray] @\
!       Native fortran data array to be copied/referenced in the {\tt field}. @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farray}. @\
! \item [indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{opt:indexflag} for a list of valid indexflag options. @\
! \item [{[copyflag]}] @\
!       Indicates whether to copy the {\tt farray} or reference it directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[staggerloc]}] @\
!       Stagger location of data in grid cells.  For valid  @\
!       predefined values see Section \ref{sec:opt:staggerloc}. @\
!       To create a custom stagger location see Section @\
!       \ref{sec:usage:staggerloc:adv}. The default @\
!       value is {\tt ESMF\_STAGGERLOC\_CENTER}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt grid}|s dimCount.  The list elements map each dimension @\
!       of the {\tt grid} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The @\
!       default is to map all of the {\tt grid}|s dimensions against the @\
!       lowest dimensions of the {\tt farray} in sequence, i.e. @\
!       {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       Unmapped {\tt farray} dimensions are undistributed Field @\
!       dimensions. @\
!       All {\tt gridToFieldMap} entries must be greater than or equal @\
!       to zero and smaller than or equal to the Field dimCount. It is erroneous @\
!       to specify the same entry multiple times unless it is zero. @\
!       If the Field dimCount is less than the Grid dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Grid dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt field}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt field}. @\
! \item [{[maxHaloLWidth]}] @\
!       Lower bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the {\tt field}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt field}.  Values default @\
!       to 0.  If values for maxHaloLWidth are specified they must be reflected in @\
!       the size of the {\tt field}.  That is, for each gridded dimension the @\
!       {\tt field} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not @\
!       implemented, the {\tt minHaloLWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method. @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[maxHaloUWidth]}] @\
!       Upper bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the {\tt field}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt field}.  Values default @\
!       to 0.  If values for maxHaloUWidth are specified they must be reflected in @\
!       the size of the {\tt field}.  That is, for each gridded dimension the @\
!       {\tt field} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ).  Although the halo operation is not @\
!       implemented, the {\tt maxHaloUWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method.  @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldSetCommitGridMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldSetCommitGrid" @\
  subroutine ESMF_FieldSetCommitGrid##mrank##D##mtypekind(field, grid, farray, & @\
    indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & @\
    ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) @\
@\
    ! input arguments @\
    type(ESMF_Field) :: field @\
    type(ESMF_Grid) :: grid                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), target :: farray @\
    type(ESMF_IndexFlag), intent(in)            :: indexflag @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    type(ESMF_StaggerLoc), intent(in), optional ::staggerloc  @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: ungriddedLBound(:) @\
    integer, intent(in), optional :: ungriddedUBound(:) @\
    integer, intent(in), optional :: maxHaloLWidth(:) @\
    integer, intent(in), optional :: maxHaloUWidth(:) @\
    integer, intent(out), optional :: rc                @\
    ! local variables @\
    type(ESMF_StaggerLoc)          :: localStaggerLoc  @\
    integer                        :: localrc  @\
    type(ESMF_GeomBase)   :: geombase @\
    type(ESMF_GridDecompType) :: decompType @\
@\
    if (present(rc)) then @\
      rc = ESMF_RC_NOT_IMPL @\
    endif @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ! make sure field, grid, farray are properly initialized @\
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) @\
    ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) @\
@\
    call ESMF_GridGetDecompType(grid, decompType, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, &   @\
        ESMF_ERR_PASSTHRU, &   @\
        ESMF_CONTEXT, rc)) return   @\
@\
    if (decompType .eq. ESMF_GRID_ARBITRARY) then @\
        if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, &  @\
                 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & @\
                 ESMF_CONTEXT, rc)  @\
           return @\
        endif @\
    endif @\
@\
    ! Set default values.  @\
    if (present(staggerloc)) then @\
       if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & @\
 	  (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then @\
           call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, &  @\
                 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", &  @\
                 ESMF_CONTEXT, rc)  @\
           return @\
	 else @\
	    localStaggerloc=staggerloc @\
	 endif @\
    else   @\
       localStaggerLoc = ESMF_STAGGERLOC_CENTER   @\
    endif   @\
@\
    geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
  ! Do General GeomBase SetCommit @\
  call ESMF_FieldSetCommitGB##mrank##D##mtypekind(field, geombase, farray, & @\
    indexflag, copyflag, gridToFieldMap, ungriddedLBound, & @\
    ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    !  link the Attribute hierarchies @\
    call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) @\
    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
                    ESMF_CONTEXT, rcToReturn=rc))  return @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_FieldSetCommitGrid##mrank##D##mtypekind  @\
!---------------------------------------------------------------------------- @\

TypeKindRankDeclarationMacro(FieldSetCommitGrid)


#define FieldSetCommitGridPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from Grid started with FieldCreateEmpty @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldSetCommit() @\
! subroutine ESMF_FieldSetCommitGridPtr<rank><type><kind>(field, grid, & @\
!   farrayPtr, copyflag, staggerloc, gridToFieldMap, & @\
!   maxHaloLWidth, maxHaloUWidth, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Field),      intent(inout)        :: field @\
!   type(ESMF_Grid),       intent(in)           :: grid @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer  :: farrayPtr @\
!   type(ESMF_CopyFlag),   intent(in), optional :: copyflag @\
!   type(ESMF_STAGGERLOC), intent(in), optional :: staggerloc @\
!   integer,               intent(in), optional :: gridToFieldMap(:) @\
!   integer,               intent(in), optional :: maxHaloLWidth(:) @\
!   integer,               intent(in), optional :: maxHaloUWidth(:) @\
!   integer,               intent(inout), optional :: rc @\
! @\
! !DESCRIPTION: @\
! This call completes an {\tt ESMF\_Field} allocated with the @\
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and @\
! associated documentation using this method see Section  @\
! \ref{sec:field:usage:create_empty_setcommit}. @\
! @\
! The fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when @\
! copyflag is {\tt ESMF\_DATA\_REF}. Note that the {\tt ESMF\_FieldDestroy} call does not deallocate @\
! the fortran data pointer in this case. This gives user more flexibility over memory management. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [field]  @\
!       The {\tt ESMF\_Field} object to be completed and @\
!       committed in this call.  The {\tt field} will have the same dimension @\
!       (dimCount) as the rank of the {\tt farrayPtr}.  @\
! \item [grid]  @\
!       The {\tt ESMF\_Grid} object to finish the Field. @\
! \item [farrayPtr] @\
!       Native fortran data pointer to be copied/referenced in the {\tt field}. @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farrayPtr}. @\
! \item [{[copyflag]}] @\
!       Indicates whether to copy the {\tt farrayPtr} or reference it directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[staggerloc]}] @\
!       Stagger location of data in grid cells.  For valid  @\
!       predefined values see Section \ref{sec:opt:staggerloc}. @\
!       To create a custom stagger location see Section @\
!       \ref{sec:usage:staggerloc:adv}. The default @\
!       value is {\tt ESMF\_STAGGERLOC\_CENTER}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt grid}|s dimCount.  The list elements map each dimension @\
!       of the {\tt grid} to a dimension in the {\tt farrayPtr} by @\
!       specifying the appropriate {\tt farrayPtr} dimension index. The @\
!       default is to map all of the {\tt grid}|s dimensions against the @\
!       lowest dimensions of the {\tt farrayPtr} in sequence, i.e. @\
!       {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       Unmapped {\tt farrayPtr} dimensions are undistributed Field @\
!       dimensions. @\
!       All {\tt gridToFieldMap} entries must be greater than or equal @\
!       to zero and smaller than or equal to the Field dimCount. It is erroneous @\
!       to specify the same entry multiple times unless it is zero. @\
!       If the Field dimCount is less than the Grid dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Grid dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[maxHaloLWidth]}] @\
!       Lower bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the {\tt field}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt field}.  Values default @\
!       to 0.  If values for maxHaloLWidth are specified they must be reflected in @\
!       the size of the {\tt field}.  That is, for each gridded dimension the @\
!       {\tt field} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not @\
!       implemented, the {\tt minHaloLWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method. @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[maxHaloUWidth]}] @\
!       Upper bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the {\tt field}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt field}.  Values default @\
!       to 0.  If values for maxHaloUWidth are specified they must be reflected in @\
!       the size of the {\tt field}.  That is, for each gridded dimension the @\
!       {\tt field} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ).  Although the halo operation is not @\
!       implemented, the {\tt maxHaloUWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method.  @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldSetCommitGridPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" @\
  subroutine ESMF_FieldSetCommitGridPtr##mrank##D##mtypekind(field, grid, farrayPtr, & @\
    copyflag, staggerloc, gridToFieldMap, & @\
    maxHaloLWidth, maxHaloUWidth, rc) @\
@\
    ! input arguments @\
    type(ESMF_Field) :: field @\
    type(ESMF_Grid) :: grid                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    type(ESMF_StaggerLoc), intent(in), optional ::staggerloc  @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: maxHaloLWidth(:) @\
    integer, intent(in), optional :: maxHaloUWidth(:) @\
    integer, intent(out), optional :: rc                @\
    ! local variables @\
    type(ESMF_StaggerLoc)          :: localStaggerLoc  @\
    integer                        :: localrc  @\
    type(ESMF_GeomBase)            :: geombase @\
    type(ESMF_GridDecompType)      :: decompType @\
@\
    if (present(rc)) then @\
      rc = ESMF_RC_NOT_IMPL @\
    endif @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ! make sure field, grid, farrayPtr are properly initialized @\
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) @\
    ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) @\
@\
    call ESMF_GridGetDecompType(grid, decompType, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, &   @\
        ESMF_ERR_PASSTHRU, &   @\
        ESMF_CONTEXT, rc)) return   @\
@\
    if (decompType .eq. ESMF_GRID_ARBITRARY) then @\
        if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, &  @\
                 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & @\
                 ESMF_CONTEXT, rc)  @\
           return @\
        endif @\
    endif @\
@\
    ! Set default values.  @\
    if (present(staggerloc)) then @\
       if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & @\
 	  (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then @\
           call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, &  @\
                 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", &  @\
                 ESMF_CONTEXT, rc)  @\
           return @\
	 else @\
	    localStaggerloc=staggerloc @\
	 endif @\
    else   @\
       localStaggerLoc = ESMF_STAGGERLOC_CENTER   @\
    endif   @\
@\
    geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
  ! Do General GeomBase SetCommit @\
  call ESMF_FieldSetCommitGBPtr##mrank##D##mtypekind(field, geombase, farrayPtr, & @\
    copyflag, gridToFieldMap, & @\
    maxHaloLWidth, maxHaloUWidth, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
@\
    !  link the Attribute hierarchies @\
    call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) @\
    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
                    ESMF_CONTEXT, rcToReturn=rc))  return @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_FieldSetCommitGridPtr##mrank##D##mtypekind  @\
!---------------------------------------------------------------------------- @\

TypeKindRankDeclarationMacro(FieldSetCommitGridPtr)


#define FieldSetCommitLSDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from LocStream started with FieldCreateEmpty @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldSetCommit() @\
! subroutine ESMF_FieldSetCommitLS<rank><type><kind>(field, locstream, & @\
!   farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, & @\
!   ungriddedUBound, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Field),      intent(inout)        :: field @\
!   type(ESMF_LocStream),  intent(in)           :: locstream @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), target  :: farray @\
!   type(ESMF_IndexFlag),  intent(in)           :: indexflag @\
!   type(ESMF_CopyFlag),   intent(in), optional :: copyflag @\
!   integer,               intent(in), optional :: gridToFieldMap(:) @\
!   integer,               intent(in), optional :: ungriddedLBound(:) @\
!   integer,               intent(in), optional :: ungriddedUBound(:) @\
!   integer,               intent(inout), optional :: rc @\
! @\
! !DESCRIPTION: @\
! This call completes an {\tt ESMF\_Field} allocated with the @\
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and @\
! associated documentation using this method see Section  @\
! \ref{sec:field:usage:create_empty_setcommit}. @\
! @\
! The fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating @\
! the retrieved data pointer is not allowed. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [field]  @\
!       The {\tt ESMF\_Field} object to be completed and @\
!       committed in this call.  The {\tt field} will have the same dimension @\
!       (dimCount) as the rank of the {\tt farray}.  @\
! \item [locstream]  @\
!       The {\tt ESMF\_LocStream} object to finish the Field. @\
! \item [farray] @\
!       Native fortran data array to be copied/referenced in the {\tt field}. @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farray}. @\
! \item [indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{opt:indexflag} for a list of valid indexflag options. @\
! \item [{[copyflag]}] @\
!       Indicates whether to copy the {\tt farray} or reference it directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt locstream}|s dimCount.  The list elements map each dimension @\
!       of the {\tt locstream} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The @\
!       default is to map all of the {\tt locstream}|s dimensions against the @\
!       lowest dimensions of the {\tt farray} in sequence, i.e. @\
!       {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       Unmapped {\tt farray} dimensions are undistributed Field @\
!       dimensions. @\
!       All {\tt gridToFieldMap} entries must be greater than or equal @\
!       to zero and smaller than or equal to the Field dimCount. It is erroneous @\
!       to specify the same entry multiple times unless it is zero. @\
!       If the Field dimCount is less than the LocStream dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       LocStream dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than locstream dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt field}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than locstream dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt field}. @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldSetCommitLSMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldSetCommitLS" @\
  subroutine ESMF_FieldSetCommitLS##mrank##D##mtypekind(field, locstream, farray, & @\
    indexflag, copyflag, gridToFieldMap, ungriddedLBound, & @\
    ungriddedUBound, rc) @\
@\
    ! input arguments @\
    type(ESMF_Field) :: field @\
    type(ESMF_LocStream) :: locstream                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), target :: farray @\
    type(ESMF_IndexFlag),  intent(in)           :: indexflag @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: ungriddedLBound(:) @\
    integer, intent(in), optional :: ungriddedUBound(:) @\
    integer, intent(out), optional :: rc                @\
    ! local variables @\
    integer                        :: localrc  @\
    type(ESMF_GeomBase)   :: geombase @\
@\
    if (present(rc)) then @\
      rc = ESMF_RC_NOT_IMPL @\
    endif @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ! make sure field, locstream, farray are properly initialized @\
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) @\
    ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) @\
@\
    geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
  ! Do General GeomBase SetCommit @\
  call ESMF_FieldSetCommitGB##mrank##D##mtypekind(field, geombase, farray, & @\
    indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & @\
    ungriddedLBound=ungriddedLBound, & @\
    ungriddedUBound=ungriddedUBound, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_FieldSetCommitLS##mrank##D##mtypekind  @\
!---------------------------------------------------------------------------- @\

TypeKindRankDeclarationMacro(FieldSetCommitLS)


#define FieldSetCommitLSPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from LocStream started with FieldCreateEmpty @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldSetCommit() @\
! subroutine ESMF_FieldSetCommitLSPtr<rank><type><kind>(field, locstream, & @\
!   farrayPtr, copyflag, gridToFieldMap, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Field),      intent(inout)        :: field @\
!   type(ESMF_LocStream),  intent(in)           :: locstream @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer  :: farrayPtr @\
!   type(ESMF_CopyFlag),   intent(in), optional :: copyflag @\
!   integer,               intent(in), optional :: gridToFieldMap(:) @\
!   integer,               intent(inout), optional :: rc @\
! @\
! !DESCRIPTION: @\
! This call completes an {\tt ESMF\_Field} allocated with the @\
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and @\
! associated documentation using this method see Section  @\
! \ref{sec:field:usage:create_empty_setcommit}. @\
! @\
! The fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when @\
! copyflag is {\tt ESMF\_DATA\_REF}. Note that the {\tt ESMF\_FieldDestroy} call does not deallocate @\
! the fortran data pointer in this case. This gives user more flexibility over memory management. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [field]  @\
!       The {\tt ESMF\_Field} object to be completed and @\
!       committed in this call.  The {\tt field} will have the same dimension @\
!       (dimCount) as the rank of the {\tt farrayPtr}.  @\
! \item [locstream]  @\
!       The {\tt ESMF\_LocStream} object to finish the Field. @\
! \item [farrayPtr] @\
!       Native fortran data pointer to be copied/referenced in the {\tt field}. @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farrayPtr}. @\
! \item [{[copyflag]}] @\
!       Indicates whether to copy the {\tt farrayPtr} or reference it directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt locstream}|s dimCount.  The list elements map each dimension @\
!       of the {\tt locstream} to a dimension in the {\tt farrayPtr} by @\
!       specifying the appropriate {\tt farrayPtr} dimension index. The @\
!       default is to map all of the {\tt locstream}|s dimensions against the @\
!       lowest dimensions of the {\tt farrayPtr} in sequence, i.e. @\
!       {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       Unmapped {\tt farrayPtr} dimensions are undistributed Field @\
!       dimensions. @\
!       All {\tt gridToFieldMap} entries must be greater than or equal @\
!       to zero and smaller than or equal to the Field dimCount. It is erroneous @\
!       to specify the same entry multiple times unless it is zero. @\
!       If the Field dimCount is less than the LocStream dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       LocStream dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldSetCommitLSPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" @\
  subroutine ESMF_FieldSetCommitLSPtr##mrank##D##mtypekind(field, locstream, farrayPtr, & @\
    copyflag, gridToFieldMap, & @\
    rc) @\
@\
    ! input arguments @\
    type(ESMF_Field) :: field @\
    type(ESMF_LocStream) :: locstream                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(out), optional :: rc                @\
    ! local variables @\
    integer                        :: localrc  @\
    type(ESMF_GeomBase)   :: geombase @\
@\
    if (present(rc)) then @\
      rc = ESMF_RC_NOT_IMPL @\
    endif @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ! make sure field, locstream, farrayPtr are properly initialized @\
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) @\
    ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) @\
@\
    geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
  ! Do General GeomBase SetCommit @\
  call ESMF_FieldSetCommitGBPtr##mrank##D##mtypekind(field, geombase, farrayPtr, & @\
    copyflag=copyflag, gridToFieldMap=gridToFieldMap, & @\
    rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_FieldSetCommitLSPtr##mrank##D##mtypekind  @\
!---------------------------------------------------------------------------- @\

TypeKindRankDeclarationMacro(FieldSetCommitLSPtr)


#define FieldSetCommitMeshDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from Mesh started with FieldCreateEmpty @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldSetCommit() @\
! subroutine ESMF_FieldSetCommitMesh<rank><type><kind>(field, mesh, & @\
!   farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, & @\
!   ungriddedUBound, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Field),      intent(inout)        :: field @\
!   type(ESMF_Mesh),       intent(in)           :: mesh @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), target  :: farray @\
!   type(ESMF_IndexFlag),  intent(in)           :: indexflag @\
!   type(ESMF_CopyFlag),   intent(in), optional :: copyflag @\
!   integer,               intent(in), optional :: gridToFieldMap(:) @\
!   integer,               intent(in), optional :: ungriddedLBound(:) @\
!   integer,               intent(in), optional :: ungriddedUBound(:) @\
!   integer,               intent(inout), optional :: rc @\
! @\
! !DESCRIPTION: @\
! This call completes an {\tt ESMF\_Field} allocated with the @\
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and @\
! associated documentation using this method see Section  @\
! \ref{sec:field:usage:create_empty_setcommit}. @\
! @\
! The fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating @\
! the retrieved data pointer is not allowed. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [field]  @\
!       The {\tt ESMF\_Field} object to be completed and @\
!       committed in this call.  The {\tt field} will have the same dimension @\
!       (dimCount) as the rank of the {\tt farray}.  @\
! \item [mesh]  @\
!       The {\tt ESMF\_Mesh} object to finish the Field. @\
! \item [farray] @\
!       Native fortran data array to be copied/referenced in the {\tt field}. @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farray}. @\
! \item [indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{opt:indexflag} for a list of valid indexflag options. @\
! \item [{[copyflag]}] @\
!       Indicates whether to copy the {\tt farray} or reference it directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt mesh}|s dimCount.  The list elements map each dimension @\
!       of the {\tt mesh} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The @\
!       default is to map all of the {\tt mesh}|s dimensions against the @\
!       lowest dimensions of the {\tt farray} in sequence, i.e. @\
!       {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       Unmapped {\tt farray} dimensions are undistributed Field @\
!       dimensions. @\
!       All {\tt gridToFieldMap} entries must be greater than or equal @\
!       to zero and smaller than or equal to the Field dimCount. It is erroneous @\
!       to specify the same entry multiple times unless it is zero. @\
!       If the Field dimCount is less than the Mesh dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Mesh dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than Mesh dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt field}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than Mesh dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt field}. @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldSetCommitMeshMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldSetCommitMesh" @\
  subroutine ESMF_FieldSetCommitMesh##mrank##D##mtypekind(field, mesh, farray, & @\
    indexflag, copyflag, gridToFieldMap, ungriddedLBound, & @\
    ungriddedUBound, rc) @\
@\
    ! input arguments @\
    type(ESMF_Field) :: field @\
    type(ESMF_Mesh) :: mesh                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), target :: farray @\
    type(ESMF_IndexFlag),  intent(in)           :: indexflag @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: ungriddedLBound(:) @\
    integer, intent(in), optional :: ungriddedUBound(:) @\
    integer, intent(out), optional :: rc                @\
    ! local variables @\
    integer                        :: localrc  @\
    type(ESMF_GeomBase)   :: geombase @\
@\
    if (present(rc)) then @\
      rc = ESMF_RC_NOT_IMPL @\
    endif @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ! make sure field, mesh, farray are properly initialized @\
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) @\
    ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) @\
@\
    geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
  ! Do General GeomBase SetCommit @\
  call ESMF_FieldSetCommitGB##mrank##D##mtypekind(field, geombase, farray, & @\
    indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & @\
    ungriddedLBound=ungriddedLBound, & @\
    ungriddedUBound=ungriddedUBound, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_FieldSetCommitMesh##mrank##D##mtypekind  @\
!---------------------------------------------------------------------------- @\

TypeKindRankDeclarationMacro(FieldSetCommitMesh)


#define FieldSetCommitMeshPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from Mesh started with FieldCreateEmpty @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldSetCommit() @\
! subroutine ESMF_FieldSetCommitMeshPtr<rank><type><kind>(field, mesh, & @\
!   farrayPtr, indexflag, copyflag, gridToFieldMap, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Field),      intent(inout)        :: field @\
!   type(ESMF_Mesh),       intent(in)           :: mesh @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer  :: farrayPtr @\
!   type(ESMF_CopyFlag),   intent(in), optional :: copyflag @\
!   integer,               intent(in), optional :: gridToFieldMap(:) @\
!   integer,               intent(inout), optional :: rc @\
! @\
! !DESCRIPTION: @\
! This call completes an {\tt ESMF\_Field} allocated with the @\
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and @\
! associated documentation using this method see Section  @\
! \ref{sec:field:usage:create_empty_setcommit}. @\
! @\
! The fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when @\
! copyflag is {\tt ESMF\_DATA\_REF}. Note that the {\tt ESMF\_FieldDestroy} call does not deallocate @\
! the fortran data pointer in this case. This gives user more flexibility over memory management. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [field]  @\
!       The {\tt ESMF\_Field} object to be completed and @\
!       committed in this call.  The {\tt field} will have the same dimension @\
!       (dimCount) as the rank of the {\tt farrayPtr}.  @\
! \item [mesh]  @\
!       The {\tt ESMF\_Mesh} object to finish the Field. @\
! \item [farrayPtr] @\
!       Native fortran data pointer to be copied/referenced in the {\tt field}. @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farrayPtr}. @\
! \item [{[copyflag]}] @\
!       Indicates whether to copy the {\tt farrayPtr} or reference it directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt mesh}|s dimCount.  The list elements map each dimension @\
!       of the {\tt mesh} to a dimension in the {\tt farrayPtr} by @\
!       specifying the appropriate {\tt farrayPtr} dimension index. The @\
!       default is to map all of the {\tt mesh}|s dimensions against the @\
!       lowest dimensions of the {\tt farrayPtr} in sequence, i.e. @\
!       {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       Unmapped {\tt farrayPtr} dimensions are undistributed Field @\
!       dimensions. @\
!       All {\tt gridToFieldMap} entries must be greater than or equal @\
!       to zero and smaller than or equal to the Field dimCount. It is erroneous @\
!       to specify the same entry multiple times unless it is zero. @\
!       If the Field dimCount is less than the Mesh dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Mesh dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldSetCommitMeshPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" @\
  subroutine ESMF_FieldSetCommitMeshPtr##mrank##D##mtypekind(field, mesh, & @\
    farrayPtr, copyflag, gridToFieldMap, rc) @\
@\
    ! input arguments @\
    type(ESMF_Field) :: field @\
    type(ESMF_Mesh) :: mesh                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(out), optional :: rc                @\
    ! local variables @\
    integer                        :: localrc  @\
    type(ESMF_GeomBase)   :: geombase @\
@\
    if (present(rc)) then @\
      rc = ESMF_RC_NOT_IMPL @\
    endif @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ! make sure field, mesh, farrayPtr are properly initialized @\
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) @\
    ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) @\
@\
    geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
  ! Do General GeomBase SetCommit @\
  call ESMF_FieldSetCommitGBPtr##mrank##D##mtypekind(field, geombase, farrayPtr, & @\
    copyflag=copyflag, gridToFieldMap=gridToFieldMap, & @\
    rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_FieldSetCommitMeshPtr##mrank##D##mtypekind  @\
!---------------------------------------------------------------------------- @\

TypeKindRankDeclarationMacro(FieldSetCommitMeshPtr)


#define FieldSetCommitGBDoc() \
!---------------------------------------------------------------------------- @\
!BOPI @\
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field started with FieldCreateEmpty @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldSetCommit() @\
! subroutine ESMF_FieldSetCommitGB<rank><type><kind>(field, geombase, & @\
!   farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, & @\
!   ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Field),      intent(inout)        :: field @\
!   type(ESMF_GeomBase),   intent(in)           :: geombase @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), target  :: farray @\
!   type(ESMF_IndexFlag),  intent(in)           :: indexflag @\
!   type(ESMF_CopyFlag),   intent(in), optional :: copyflag @\
!   integer,               intent(in), optional :: gridToFieldMap(:) @\
!   integer,               intent(in), optional :: ungriddedLBound(:) @\
!   integer,               intent(in), optional :: ungriddedUBound(:) @\
!   integer,               intent(in), optional :: maxHaloLWidth(:) @\
!   integer,               intent(in), optional :: maxHaloUWidth(:) @\
!   integer,               intent(inout), optional :: rc @\
! @\
! !DESCRIPTION: @\
! This call completes an {\tt ESMF\_Field} allocated with the @\
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and @\
! associated documentation using this method see Section  @\
! \ref{sec:field:usage:create_empty_setcommit}. @\
! @\
! The fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating @\
! the retrieved data pointer is not allowed. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [field]  @\
!       The {\tt ESMF\_Field} object to be completed and @\
!       committed in this call.  The {\tt field} will have the same dimension @\
!       (dimCount) as the rank of the {\tt farray}.  @\
! \item [geombase]  @\
!       The {\tt ESMF\_GeomBase} object to finish the Field. @\
! \item [farray] @\
!       Native fortran data array to be copied/referenced in the {\tt field}. @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farray}. @\
! \item [indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{opt:indexflag} for a list of valid indexflag options. @\
! \item [{[copyflag]}] @\
!       Indicates whether to copy the {\tt farray} or reference it directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt geombase}|s dimCount.  The list elements map each dimension @\
!       of the {\tt geombase} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The @\
!       default is to map all of the {\tt geombase}|s dimensions against the @\
!       lowest dimensions of the {\tt farray} in sequence, i.e. @\
!       {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       Unmapped {\tt farray} dimensions are undistributed Field @\
!       dimensions. @\
!       All {\tt gridToFieldMap} entries must be greater than or equal @\
!       to zero and smaller than or equal to the Field dimCount. It is erroneous @\
!       to specify the same entry multiple times unless it is zero. @\
!       If the Field dimCount is less than the Grid dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Grid dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt field}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt field}. @\
! \item [{[maxHaloLWidth]}] @\
!       Lower bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the {\tt field}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt field}.  Values default @\
!       to 0.  If values for maxHaloLWidth are specified they must be reflected in @\
!       the size of the {\tt field}.  That is, for each gridded dimension the @\
!       {\tt field} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not @\
!       implemented, the {\tt minHaloLWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method. @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[maxHaloUWidth]}] @\
!       Upper bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the {\tt field}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt field}.  Values default @\
!       to 0.  If values for maxHaloUWidth are specified they must be reflected in @\
!       the size of the {\tt field}.  That is, for each gridded dimension the @\
!       {\tt field} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ).  Although the halo operation is not @\
!       implemented, the {\tt maxHaloUWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method.  @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOPI @\
!---------------------------------------------------------------------------- @\

#define FieldSetCommitGBMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldSetCommitGB" @\
  subroutine ESMF_FieldSetCommitGB##mrank##D##mtypekind(field, geombase, farray, & @\
    indexflag, copyflag, gridToFieldMap, ungriddedLBound, & @\
    ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) @\
@\
    ! input arguments @\
    type(ESMF_Field) :: field @\
    type(ESMF_GeomBase) :: geombase            @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), target :: farray @\
    type(ESMF_IndexFlag),   intent(in)           :: indexflag @\
    type(ESMF_CopyFlag),    intent(in), optional :: copyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: ungriddedLBound(:) @\
    integer, intent(in), optional :: ungriddedUBound(:) @\
    integer, intent(in), optional :: maxHaloLWidth(:) @\
    integer, intent(in), optional :: maxHaloUWidth(:) @\
    integer, intent(out), optional :: rc                @\
    ! local variables @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: fpointer @\
    integer                        :: localrc, i, j, count @\
    integer                        :: memDimCount, fieldDimCount, fieldUngriddedDimCount @\
    integer                        :: gridDimCount, gridDimCount_norep  @\
    integer                        :: grid_repdimcount @\
    integer                        :: elementCount  @\
    integer                        :: ungriddedIndex(ESMF_MAXDIM) @\
    integer                        :: distgridToArrayMap (ESMF_MAXDIM) @\
    integer                        :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) @\
    integer                        :: localUngriddedLBound (ESMF_MAXDIM) @\
    integer                        :: localUngriddedUBound (ESMF_MAXDIM) @\
    integer                        :: localGridToFieldMap (ESMF_MAXDIM) @\
    integer                        :: localMaxHaloLWidth (ESMF_MAXDIM) @\
    integer                        :: localMaxHaloUWidth (ESMF_MAXDIM) @\
    logical                        :: isGridded(ESMF_MAXDIM) @\
    integer                        :: distgridToGridMap(ESMF_MAXDIM) @\
    type(ESMF_Array)               :: array @\
    type(ESMF_DistGrid)            :: distgrid @\
    integer                        :: fieldUndistDimCount                         @\
    logical                        :: flipflop(ESMF_MAXDIM) @\
    type(ESMF_IndexFlag)           :: g_indexflag @\
    logical                        :: found @\
    type(ESMF_GridDecompType)      :: decompType @\
    type(ESMF_GeomType)            :: geomType @\
    type(ESMF_Grid)                :: grid @\
    integer                        :: distgridDimCount, distgridDimCount_norep, arbdim @\
@\
    if (present(rc)) then @\
      rc = ESMF_RC_NOT_IMPL @\
    endif @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ! make sure field, grid, farray are properly initialized @\
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) @\
    ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) @\
@\
    ! Get number of grid dimensions, number @\
    ! of distributed grid dimensions, distgrid, @\
    ! number of ungridded Field dimensions, @\
    ! and number of undistributed Field Dimensions @\
    call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & @\
          distgridToGridMap=distgridToGridMap, & @\
          distgrid=distgrid, indexflag=g_indexflag, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    if(.not. (indexflag .eq. g_indexflag)) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   @\
             "- user specified indexflag must be identical with Grid indexflag", &  @\
               ESMF_CONTEXT, rc) @\
        return @\
    endif @\
@\
    call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & @\
      rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    if (elementCount > 0) then @\
      ! The following use of fptr is a bit of trickery to get all F90 @\
      ! compilers to cooperate. For some compilers the associated() test @\
      ! will return .false. for farray of size 0. Some of those compilers @\
      ! will produce a run-time error in size(fptr). Other compilers will @\
      ! return .true. for the associated() test but return 0 in size(). @\
      fpointer => farray @\
      if(.not. associated(fpointer,farray)) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, &  @\
          "- farray is not associated with memory allocation)", & @\
          ESMF_CONTEXT, rc)  @\
        return @\
      endif @\
@\
      if (size(fpointer)==0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, &  @\
          "- farray is not associated with memory allocation)", & @\
          ESMF_CONTEXT, rc)  @\
        return @\
      endif @\
    endif @\
@\
    ! Check if geombase is a grid, if so, check if it is arbitrary @\
    decompType = ESMF_GRID_NONARBITRARY @\
    call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, &   @\
        ESMF_ERR_PASSTHRU, &   @\
        ESMF_CONTEXT, rc)) return   @\
 @\
    if (geomType .eq. ESMF_GEOMTYPE_GRID) then @\
       call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) @\
       if (ESMF_LogMsgFoundError(localrc, &   @\
           ESMF_ERR_PASSTHRU, &   @\
           ESMF_CONTEXT, rc)) return   @\
       call ESMF_GridGetDecompType(grid, decompType, rc=localrc) @\
       if (ESMF_LogMsgFoundError(localrc, &   @\
           ESMF_ERR_PASSTHRU, &   @\
           ESMF_CONTEXT, rc)) return   @\
    endif @\
@\
    ! Check the size of the native array. @\
    memDimCount = mrank @\
@\
    ! Error Check Input @\
    grid_repdimcount = 0 @\
    if (present(gridToFieldMap)) then  @\
         if (size(gridToFieldMap) .ne. gridDimCount) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &  @\
          "- gridToFieldMap size must equal to grid_rank", & @\
            ESMF_CONTEXT, rc)  @\
          return @\
         endif @\
        do i = 1, gridDimCount @\
            if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 @\
        enddo @\
    endif @\
    gridDimCount_norep = gridDimCount - grid_repdimcount @\
@\
    if (present(gridToFieldMap)) then @\
      localGridToFieldMap(1:gridDimCount) = & @\
         gridToFieldMap (1:gridDimCount) @\
    else @\
      do i = 1, gridDimCount @\
        localGridToFieldMap(i) = i @\
      enddo @\
    endif @\
@\
    if (decompType .eq. ESMF_GRID_NONARBITRARY) then @\
	    fieldDimCount = memDimCount @\
    else @\
        call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & @\
	    rc=localrc) @\
        if (ESMF_LogMsgFoundError(localrc, &   @\
            ESMF_ERR_PASSTHRU, &   @\
            ESMF_CONTEXT, rc)) return   @\
        ! find out how many grid dimensions are arbitrarily distributed and calculate  @\
        ! fieldDimCount accordingly @\
        arbdim = 0 @\
        do i=1,gridDimCount @\
          if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 @\
        enddo @\
        fieldDimCount = memDimCount + arbdim - 1 @\
 @\
        ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. @\
        ! If one arb dimension is replicated, all the arb. dimensions have to be replicated @\
        if (grid_repdimcount .ne. 0) then @\
          do i = 1,gridDimCount @\
            if(localGridToFieldMap(i) == 0) then @\
                found = .false. @\
                do j=1,arbdim @\
                    if (distgridToGridMap(j) .eq. i) found = .true. @\
                enddo @\
                if (found) then @\
                  ! one arb.dimension is a replicated dimension, check if other arb dimensions are @\
                  ! also replicated @\
                  do j=1,arbdim @\
                    if (distgridToGridMap(j) .ne. i) then @\
                        if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then @\
                            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &    @\
                                "- Arb. grid dimensions have to be either all replicated or not replicated", &   @\
                                ESMF_CONTEXT, rc) @\
                            return @\
                        endif @\
                    endif @\
                  enddo @\
                  ! all arb. dimension are replication, jump out of the first do loop @\
                  ! fieldDimCount should be the same as the memDimCount @\
                  fieldDimCount = memDimCount @\
                  exit @\
                endif	 @\
             endif @\
           enddo @\
        endif        	 @\
    endif @\
@\
    if(fieldDimCount .lt. gridDimCount_norep) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &  @\
            "- farray rank must be greater than or equal to grid rank", & @\
              ESMF_CONTEXT, rc)  @\
        return @\
    endif @\
!   refer to ticket 1888180 @\
!    if(fieldDimCount .gt. gridDimCount_norep) then @\
!      if( (.not. present(ungriddedLBound)) .or. & @\
!          (.not. present(ungriddedUBound)) ) then @\
!        call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & @\
!         "- ungridded bounds must be present when Field has ungridded dimension(s)", & @\
!           ESMF_CONTEXT, rc) @\
!        return @\
!      endif @\
!    endif @\
@\
    ! ungridded dimensions plus replicated dimensions @\
    fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount @\
    fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount @\
@\
    ! Error Check Input @\
    if (present(ungriddedLBound)) then  @\
         if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then @\
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &  @\
                "- ungriddedLBound size must equal to array_rank-grid_rank", & @\
                ESMF_CONTEXT, rc)  @\
            return @\
         endif @\
    endif @\
@\
    if (present(ungriddedUBound)) then  @\
         if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then @\
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &  @\
                "- ungriddedUBound size must equal to array_rank-grid_rank", & @\
                ESMF_CONTEXT, rc)  @\
            return @\
         endif @\
    endif @\
@\
    if (present(maxHaloLWidth)) then  @\
         if (size(maxHaloLWidth) .ne. gridDimCount_norep) then @\
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &  @\
                "- maxHaloLWidth must equal to gridded dimCount", & @\
                ESMF_CONTEXT, rc)  @\
            return @\
         endif @\
    endif @\
@\
    if (present(maxHaloUWidth)) then  @\
         if (size(maxHaloUWidth) .ne. gridDimCount_norep) then @\
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &  @\
                "- maxHaloUWidth must equal to gridded dimCount", & @\
                ESMF_CONTEXT, rc)  @\
            return @\
         endif @\
    endif @\
@\
    ! gridToFieldMap elements must be in range 0...fieldRank and unique @\
    ! algorithm to check element uniqueness: @\
    !   run time: O(ESMF_MAXDIM) @\
    !   memory:   O(2*ESMF_MAXDIM) @\
    !          or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector @\
    flipflop = .false. @\
    do i = 1, gridDimCount @\
       if(localGridToFieldMap(i) .lt. 0 .or. & @\
         localGridToFieldMap(i) .gt. fieldDimCount) then @\
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &  @\
                 "- gridToFieldMap element must be within range 0...array rank", & @\
                   ESMF_CONTEXT, rc)  @\
           return @\
       endif @\
       if(localGridToFieldMap(i) /= 0) then @\
	   if(flipflop(localGridToFieldMap(i))) then @\
	       call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &  @\
	    	 "- gridToFieldMap element must be unique", & @\
	    	   ESMF_CONTEXT, rc)  @\
	       return @\
	   endif @\
	   flipflop(localGridToFieldMap(i)) = .true. @\
	endif @\
    enddo @\
@\
    if(present(maxHaloLWidth)) then @\
      localMaxHaloLWidth(1:gridDimCount_norep) = & @\
         maxHaloLWidth (1:gridDimCount_norep) @\
    else @\
         localMaxHaloLWidth = 0 @\
    endif @\
@\
    if(present(maxHaloUWidth)) then @\
      localMaxHaloUWidth(1:gridDimCount_norep) = & @\
         maxHaloUWidth (1:gridDimCount_norep) @\
    else @\
         localMaxHaloUWidth = 0 @\
    endif @\
@\
    ! Here we get the lbounds and ubounds for ungridded @\
    ! dimensions from the native array, if it is not input @\
    ! through the argument list.  First we need to set up @\
    ! an index array that holds the ungridded dimensions of @\
    ! the native array. @\
@\
    ! Since we are saving the ungriddedIndex calculate it even  @\
    ! if ungridded bounds are present @\
@\
    ! Figure out which dims are ungridded @\
    isGridded = .false. @\
    do i=1, gridDimCount @\
        if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. @\
    enddo @\
@\
    ! Use ungridded info to figure out the map from ungridded to field dims @\
    count=1 @\
    do i=1,fieldDimCount @\
      if (.not. isGridded(i)) then @\
          ungriddedIndex(count)=i  @\
          count=count+1            @\
      endif                        @\
    enddo                          @\
@\
    ! set Array ungridded bounds depending on what user provides@\
    if (present(ungriddedLBound)) then @\
       if(present(ungriddedUBound)) then @\
         ! Both present so copy @\
         localUngriddedLBound(1:fieldUngriddedDimCount) = & @\
              ungriddedLBound(1:fieldUngriddedDimCount) @\
         localUngriddedUBound(1:fieldUngriddedDimCount) = & @\
             ungriddedUBound(1:fieldUngriddedDimCount) @\
       else  @\
         ! Copy lower bound and make upper bound high enough to fit @\
         localUngriddedLBound(1:fieldUngriddedDimCount) = & @\
             ungriddedLBound(1:fieldUngriddedDimCount) @\
         do i=1, fieldUngriddedDimCount        @\
           localUngriddedUBound(i) = ungriddedLBound(i)+ & @\
             size (farray,ungriddedIndex(i))-1 @\
         enddo   @\
       endif @\
     else  @\
       if(present(ungriddedUBound)) then @\
         ! Copy upper bound and make lower bound low enough to fit @\
         do i=1, fieldUngriddedDimCount        @\
           localUngriddedLBound(i) = ungriddedUBound(i)- & @\
             size (farray,ungriddedIndex(i))+1 @\
         enddo   @\
         localUngriddedUBound(1:fieldUngriddedDimCount) = & @\
             ungriddedUBound(1:fieldUngriddedDimCount) @\
       else  @\
         ! No user info copy array bounds @\
         ! Note: assumed shape bounds will be 1...size @\
         do i=1, fieldUngriddedDimCount        @\
            localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) @\
            localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) @\
        enddo   @\
      endif @\
    endif @\
@\
    call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
    distgridDimCount_norep = memDimCount - fieldUngriddedDimCount  @\
@\
    ! The undistributed info from the Grid needs to be @\
    ! combined with the ungridded info from the Field in order @\
    ! to create the Array for the Field. @\
    call ESMF_GeomBaseGetArrayInfo(geombase, & @\
         gridToFieldMap=localGridToFieldMap, & @\
         ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & @\
         ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & @\
         distgridToArrayMap=distgridToArrayMap, & @\
         undistLBound=undistLBound, undistUBound=undistUBound, & @\
         rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    ! Create Array with undistributed dimensions                                @\
    if (decompType .eq. ESMF_GRID_NONARBITRARY) then @\
        array = ESMF_ArrayCreate(farray, distgrid=distgrid, & @\
                indexflag=indexflag, copyflag=copyflag, & @\
                distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & @\
                undistLBound=undistLBound(1:fieldUndistDimCount), & @\
                undistUBound=undistUBound(1:fieldUndistDimCount), & @\
                totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & @\
                totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & @\
                rc=localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
               ESMF_ERR_PASSTHRU, & @\
               ESMF_CONTEXT, rc)) return @\
    else @\
        array = ESMF_ArrayCreate(farray, distgrid=distgrid, & @\
                indexflag=indexflag, copyflag=copyflag, & @\
                distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & @\
                undistLBound=undistLBound(1:fieldUndistDimCount), & @\
                undistUBound=undistUBound(1:fieldUndistDimCount), & @\
                rc=localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
               ESMF_ERR_PASSTHRU, & @\
               ESMF_CONTEXT, rc)) return @\
    endif @\
@\
    field%ftypep%array = array @\
@\
    ! set array_internal to .true. because field%array is internal @\
    field%ftypep%array_internal = .true. @\
@\
    ! Should call a common FieldSetCommitConstructor here instead @\
    ! of just setting things up ourselves @\
    ! (The field Sets were all moved here in preparation for this) @\
    field%ftypep%gridToFieldMap(1:gridDimCount) = & @\
       localGridToFieldMap(1:gridDimCount) @\
    field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & @\
       localMaxHaloLWidth (1:gridDimCount_norep) @\
    field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & @\
       localMaxHaloUWidth (1:gridDimCount_norep) @\
    field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & @\
       localUngriddedLBound(1:fieldUngriddedDimCount) @\
    field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & @\
       localUngriddedUBound(1:fieldUngriddedDimCount) @\
    field%ftypep%datastatus = ESMF_STATUS_READY @\
    field%ftypep%geombase  = geombase @\
    field%ftypep%gridstatus = ESMF_STATUS_READY @\
    call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
    field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount @\
@\
    call ESMF_FieldValidate(field, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
      ESMF_ERR_PASSTHRU, & @\
      ESMF_CONTEXT, rc)) return @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_FieldSetCommitGB##mrank##D##mtypekind  @\
!---------------------------------------------------------------------------- @\

TypeKindRankDeclarationMacro(FieldSetCommitGB)


#define FieldSetCommitGBPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOPI @\
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field started with FieldCreateEmpty @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldSetCommit() @\
! subroutine ESMF_FieldSetCommitGBPtr<rank><type><kind>(field, geombase, & @\
!   farrayPtr, copyflag, gridToFieldMap, & @\
!   maxHaloLWidth, maxHaloUWidth, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Field),      intent(inou)         :: field @\
!   type(ESMF_GeomBase),   intent(in)           :: geombase @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer  :: farrayPtr @\
!   type(ESMF_CopyFlag),   intent(in), optional :: copyflag @\
!   integer,               intent(in), optional :: gridToFieldMap(:) @\
!   integer,               intent(in), optional :: maxHaloLWidth(:) @\
!   integer,               intent(in), optional :: maxHaloUWidth(:) @\
!   integer,               intent(inout), optional :: rc @\
! @\
! !DESCRIPTION: @\
! This call completes an {\tt ESMF\_Field} allocated with the @\
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and @\
! associated documentation using this method see Section  @\
! \ref{sec:field:usage:create_empty_setcommit}. @\
! @\
! The fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when @\
! copyflag is {\tt ESMF\_DATA\_REF}. Note that the {\tt ESMF\_FieldDestroy} call does not deallocate @\
! the fortran data pointer in this case. This gives user more flexibility over memory management. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [field]  @\
!       The {\tt ESMF\_Field} object to be completed and @\
!       committed in this call.  The {\tt field} will have the same dimension @\
!       (dimCount) as the rank of the {\tt farrayPtr}.  @\
! \item [geombase]  @\
!       The {\tt ESMF\_GeomBase} object to finish the Field.  The dimCount of the @\
!       GeomBase must be smaller than or equal to the rank of the {\tt farrayPtr}. @\
! \item [farrayPtr] @\
!       Native fortran data pointer to be copied/referenced in the {\tt field}. @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farrayPtr}. @\
! \item [{[copyflag]}] @\
!       Indicates whether to copy the {\tt farrayPtr} or reference it directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt geombase}|s dimCount.  The list elements map each dimension @\
!       of the {\tt geombase} to a dimension in the {\tt farrayPtr} by @\
!       specifying the appropriate {\tt farrayPtr} dimension index. The @\
!       default is to map all of the {\tt geombase}|s dimensions against the @\
!       lowest dimensions of the {\tt farrayPtr} in sequence, i.e. @\
!       {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       Unmapped {\tt farrayPtr} dimensions are undistributed Field @\
!       dimensions. @\
!       All {\tt gridToFieldMap} entries must be greater than or equal @\
!       to zero and smaller than or equal to the Field dimCount. It is erroneous @\
!       to specify the same entry multiple times unless it is zero. @\
!       If the Field dimCount is less than the Grid dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Grid dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[maxHaloLWidth]}] @\
!       Lower bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the {\tt field}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt field}.  Values default @\
!       to 0.  If values for maxHaloLWidth are specified they must be reflected in @\
!       the size of the {\tt field}.  That is, for each gridded dimension the @\
!       {\tt field} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not @\
!       implemented, the {\tt minHaloLWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method. @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[maxHaloUWidth]}] @\
!       Upper bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the {\tt field}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt field}.  Values default @\
!       to 0.  If values for maxHaloUWidth are specified they must be reflected in @\
!       the size of the {\tt field}.  That is, for each gridded dimension the @\
!       {\tt field} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ).  Although the halo operation is not @\
!       implemented, the {\tt maxHaloUWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method.  @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOPI @\
!---------------------------------------------------------------------------- @\

#define FieldSetCommitGBPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" @\
  subroutine ESMF_FieldSetCommitGBPtr##mrank##D##mtypekind(field, geombase, farrayPtr, & @\
    copyflag, gridToFieldMap, & @\
    maxHaloLWidth, maxHaloUWidth, rc) @\
@\
    ! input arguments @\
    type(ESMF_Field) :: field @\
    type(ESMF_GeomBase) :: geombase            @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: maxHaloLWidth(:) @\
    integer, intent(in), optional :: maxHaloUWidth(:) @\
    integer, intent(out), optional :: rc                @\
    ! local variables @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: fpointer @\
    integer                        :: localrc, i, j @\
    integer                        :: fieldDimCount @\
    integer                        :: memDimCount, gridDimCount, gridDimCount_norep  @\
    integer                        :: grid_repdimcount @\
    integer                        :: elementCount  @\
    integer                        :: distgridToArrayMap (ESMF_MAXDIM) @\
    integer                        :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) @\
    integer                        :: localGridToFieldMap (ESMF_MAXDIM) @\
    integer                        :: localMaxHaloLWidth (ESMF_MAXDIM) @\
    integer                        :: localMaxHaloUWidth (ESMF_MAXDIM) @\
    integer                        :: distgridToGridMap(ESMF_MAXDIM) @\
    type(ESMF_Array)               :: array @\
    type(ESMF_DistGrid)            :: distgrid @\
    integer                        :: fieldUndistDimCount                         @\
    logical                        :: flipflop(ESMF_MAXDIM) @\
    type(ESMF_IndexFlag)           :: indexflag @\
    logical                        :: found @\
    type(ESMF_GridDecompType)      :: decompType @\
    type(ESMF_GeomType)            :: geomType @\
    type(ESMF_Grid)                :: grid @\
    integer                        :: distgridDimCount, distgridDimCount_norep, arbdim @\
@\
    if (present(rc)) then @\
      rc = ESMF_RC_NOT_IMPL @\
    endif @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ! make sure field, grid, farrayPtr are properly initialized @\
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) @\
    ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) @\
@\
    ! Get number of grid dimensions, number @\
    ! of distributed grid dimensions, distgrid, @\
    ! number of ungridded Field dimensions, @\
    ! and number of undistributed Field Dimensions @\
    call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & @\
          distgridToGridMap=distgridToGridMap, & @\
          distgrid=distgrid, indexflag=indexflag, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & @\
      rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    if (elementCount > 0) then @\
      ! The following use of fptr is a bit of trickery to get all F90 @\
      ! compilers to cooperate. For some compilers the associated() test @\
      ! will return .false. for farray of size 0. Some of those compilers @\
      ! will produce a run-time error in size(fptr). Other compilers will @\
      ! return .true. for the associated() test but return 0 in size(). @\
      fpointer => farrayPtr @\
      if(.not. associated(fpointer,farrayPtr)) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, &  @\
          "- farrayPtr is not associated with memory allocation)", & @\
          ESMF_CONTEXT, rc)  @\
        return @\
      endif @\
@\
      if (size(fpointer)==0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, &  @\
          "- farrayPtr is not associated with memory allocation)", & @\
          ESMF_CONTEXT, rc)  @\
        return @\
      endif @\
    endif @\
    ! Check if geombase is a grid, if so, check if it is arbitrary @\
    decompType = ESMF_GRID_NONARBITRARY @\
    call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, &   @\
        ESMF_ERR_PASSTHRU, &   @\
        ESMF_CONTEXT, rc)) return   @\
 @\
    if (geomType .eq. ESMF_GEOMTYPE_GRID) then @\
       call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) @\
       if (ESMF_LogMsgFoundError(localrc, &   @\
           ESMF_ERR_PASSTHRU, &   @\
           ESMF_CONTEXT, rc)) return   @\
       call ESMF_GridGetDecompType(grid, decompType, rc=localrc) @\
       if (ESMF_LogMsgFoundError(localrc, &   @\
           ESMF_ERR_PASSTHRU, &   @\
           ESMF_CONTEXT, rc)) return   @\
    endif @\
@\
    ! Error Check Input @\
    ! And count the number of replicated dimensions in the Grid @\
    grid_repdimcount = 0 @\
    if (present(gridToFieldMap)) then  @\
         if (size(gridToFieldMap) .ne. gridDimCount) then @\
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &  @\
                  "- gridToFieldMap size must equal to grid_rank", & @\
                    ESMF_CONTEXT, rc)  @\
            return @\
         endif @\
        do i = 1, gridDimCount @\
            if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 @\
        enddo @\
    endif @\
    gridDimCount_norep = gridDimCount - grid_repdimcount @\
    if (present(gridToFieldMap)) then @\
      localGridToFieldMap(1:gridDimCount) = & @\
         gridToFieldMap (1:gridDimCount) @\
    else @\
      do i = 1, gridDimCount @\
        localGridToFieldMap(i) = i @\
      enddo @\
    endif @\
@\
    ! Check the size of the native array. @\
    memDimCount = mrank @\
@\
    if (decompType .eq. ESMF_GRID_NONARBITRARY) then @\
	    fieldDimCount = memDimCount @\
    else @\
        call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & @\
	    rc=localrc) @\
        if (ESMF_LogMsgFoundError(localrc, &   @\
            ESMF_ERR_PASSTHRU, &   @\
            ESMF_CONTEXT, rc)) return   @\
        ! find out how many grid dimensions are arbitrarily distributed and calculate  @\
        ! fieldDimCount accordingly @\
        arbdim = 0 @\
        do i=1,gridDimCount @\
          if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 @\
        enddo @\
        fieldDimCount = memDimCount + arbdim - 1 @\
 @\
        ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. @\
        ! If one arb dimension is replicated, all the arb. dimensions have to be replicated @\
        if (grid_repdimcount .ne. 0) then @\
          do i = 1,gridDimCount @\
            if(localGridToFieldMap(i) == 0) then @\
                found = .false. @\
                do j=1,arbdim @\
                    if (distgridToGridMap(j) .eq. i) found = .true. @\
                enddo @\
                if (found) then @\
                  ! one arb.dimension is a replicated dimension, check if other arb dimensions are @\
                  ! also replicated @\
                  do j=1,arbdim @\
                    if (distgridToGridMap(j) .ne. i) then @\
                        if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then @\
                            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &    @\
                                "- Arb. grid dimensions have to be either all replicated or not replicated", &   @\
                                ESMF_CONTEXT, rc) @\
                            return @\
                        endif @\
                    endif @\
                  enddo @\
                  ! all arb. dimension are replication, jump out of the first do loop @\
                  ! fieldDimCount should be the same as the memDimCount @\
                  fieldDimCount = memDimCount @\
                  exit @\
                endif	 @\
             endif @\
           enddo @\
        endif        	 @\
    endif @\
@\
    if(fieldDimCount .lt. gridDimCount_norep) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &  @\
            "- farrayPtr rank must be greater than or equal to grid rank", & @\
              ESMF_CONTEXT, rc)  @\
        return @\
    endif @\
@\
    ! ungridded dimensions plus replicated dimensions @\
    fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount @\
@\
    if (present(maxHaloLWidth)) then  @\
         if (size(maxHaloLWidth) .ne. gridDimCount_norep) then @\
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &  @\
                  "- maxHaloLWidth must equal to gridded dimCount", & @\
                    ESMF_CONTEXT, rc)  @\
            return @\
         endif @\
    endif @\
@\
    if (present(maxHaloUWidth)) then  @\
         if (size(maxHaloUWidth) .ne. gridDimCount_norep) then @\
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &  @\
                  "- maxHaloUWidth must equal to gridded dimCount", & @\
                    ESMF_CONTEXT, rc)  @\
            return @\
         endif @\
    endif @\
@\
    ! gridToFieldMap elements must be in range 0...fieldRank and unique @\
    ! algorithm to check element uniqueness: @\
    !   run time: O(ESMF_MAXDIM) @\
    !   memory:   O(2*ESMF_MAXDIM) @\
    !          or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector @\
    flipflop = .false. @\
    do i = 1, gridDimCount @\
        if(localGridToFieldMap(i) .lt. 0 .or. & @\
          localGridToFieldMap(i) .gt. fieldDimCount) then @\
            call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &  @\
                  "- gridToFieldMap element must be within range 0...array rank", & @\
                    ESMF_CONTEXT, rc)  @\
            return @\
        endif @\
        if(localGridToFieldMap(i) /= 0) then @\
           if(flipflop(localGridToFieldMap(i))) then @\
               call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &  @\
                     "- gridToFieldMap element must be unique", & @\
                       ESMF_CONTEXT, rc)  @\
               return @\
           endif @\
           flipflop(localGridToFieldMap(i)) = .true. @\
        endif @\
    enddo @\
@\
    if(present(maxHaloLWidth)) then @\
      localMaxHaloLWidth(1:gridDimCount_norep) = & @\
         maxHaloLWidth (1:gridDimCount_norep) @\
    else @\
         localMaxHaloLWidth = 0 @\
    endif @\
@\
    if(present(maxHaloUWidth)) then @\
      localMaxHaloUWidth(1:gridDimCount_norep) = & @\
         maxHaloUWidth (1:gridDimCount_norep) @\
    else @\
         localMaxHaloUWidth = 0 @\
    endif @\
@\
    call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
    distgridDimCount_norep = memDimCount - fieldUndistDimCount @\
@\
    ! The undistributed info from the Grid needs to be @\
    ! combined with the ungridded info from the Field in order @\
    ! to create the Array for the Field. @\
    call ESMF_GeomBaseGetArrayInfo(geombase, & @\
         gridToFieldMap=localGridToFieldMap, & @\
         distgridToArrayMap=distgridToArrayMap, & @\
         undistLBound=undistLBound, undistUBound=undistUBound, & @\
         rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    ! Create Array with undistributed dimensions                                @\
    if (decompType .eq. ESMF_GRID_NONARBITRARY) then @\
        array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & @\
                distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & @\
                totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & @\
                totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & @\
                rc=localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
               ESMF_ERR_PASSTHRU, & @\
               ESMF_CONTEXT, rc)) return @\
    else @\
        array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & @\
                distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & @\
                rc=localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
               ESMF_ERR_PASSTHRU, & @\
               ESMF_CONTEXT, rc)) return @\
    endif @\
@\
    field%ftypep%array = array @\
@\
    ! set array_internal to .true. because field%array is internal @\
    field%ftypep%array_internal = .true. @\
@\
    ! Should call a common FieldSetCommitPtrConstructor here instead @\
    ! of just setting things up ourselves @\
    ! (The field Sets were all moved here in preparation for this) @\
    field%ftypep%gridToFieldMap(1:gridDimCount) = & @\
       localGridToFieldMap(1:gridDimCount) @\
    field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & @\
       localMaxHaloLWidth (1:gridDimCount_norep) @\
    field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & @\
       localMaxHaloUWidth (1:gridDimCount_norep) @\
    field%ftypep%datastatus = ESMF_STATUS_READY @\
    field%ftypep%geombase  = geombase @\
    field%ftypep%gridstatus = ESMF_STATUS_READY @\
    call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
    field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount @\
@\
    call ESMF_FieldValidate(field, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
      ESMF_ERR_PASSTHRU, & @\
      ESMF_CONTEXT, rc)) return @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_FieldSetCommitGBPtr##mrank##D##mtypekind  @\
!---------------------------------------------------------------------------- @\

TypeKindRankDeclarationMacro(FieldSetCommitGBPtr)


end module ESMF_FieldSetCoMod
