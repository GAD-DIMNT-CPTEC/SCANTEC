! $Id: ESMF_Attribute.cppF90,v 1.56.2.1 2010/02/05 20:03:28 svasquez Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2010, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_Attribute.F90"
!==============================================================================
!
! ESMF Attribute Module
!
! (all lines between the !BOP and !EOP markers will be included in the
! automated document processing.)
!------------------------------------------------------------------------------
! one blank line for protex processing - in case all routines here are
! marked internal (BOPI/EOPI), the output file will still have contents.
!BOP

!EOP

!------------------------------------------------------------------------------
! module definition

module ESMF_AttributeMod
!
!------------------------------------------------------------------------------
! INCLUDES
^include "ESMF.h"
#include "ESMF_TypeKindMacros.hcppF90"
^define ESMF_NO_INTEGER_1_BYTE
^define ESMF_NO_INTEGER_2_BYTE

!==============================================================================
!BOPI
! !MODULE: ESMF_AttributeMod - Attribute API
!
! !DESCRIPTION:
!
! The code in this file implements the Attribute defined type
!  and functions.  This is an
!  interface to the actual C++ Attribute class implementation 
!  in the ../../Infrastructure/Attribute dir.
!
! See the ESMF Developers Guide document for more details.
!
!------------------------------------------------------------------------------
! !USES:
  use ESMF_BaseMod
  use ESMF_UtilTypesMod     ! ESMF utility types
  use ESMF_InitMacrosMod    ! ESMF initializer macros
  use ESMF_LogErrMod        ! ESMF error handling
  use ESMF_ArrayMod
  Use ESMF_ArrayBundleMod
  use ESMF_CompMod
  use ESMF_CplCompMod
  use ESMF_GridCompMod
  use ESMF_DistGridMod
  use ESMF_FieldMod
  use ESMF_FieldBundleMod
  use ESMF_GridMod
  use ESMF_StateTypesMod
  use ESMF_StateVaMod
  use ESMF_StateMod
  use ESMF_VMMod

  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! ! ESMF_Attribute
!
!------------------------------------------------------------------------------

  type ESMF_Attribute
  sequence
    character(len=ESMF_MAXSTR)  :: attr_name
    type(ESMF_DataValue)        :: attr_value
  end type

!------------------------------------------------------------------------------
!
! !DESCRIPTION:
!     The following routines apply to {\tt ESMF\_Array}, {\tt ESMF\_ArrayBundle},
!     {\ESMF_DistGrid}, {\tt ESMF\_Field},{\tt ESMF\_FieldBundle}, {\tt ESMF\_Grid}, 
!     and {\tt ESMF\_State}.  
!
! !PUBLIC MEMBER FUNCTIONS:
!
!   Classes
      public ESMF_Attribute
      
!  Attribute methods
      public ESMF_AttributeAdd
      public ESMF_AttributeCopy
      public ESMF_AttributeRemove
      public ESMF_AttributeGet
      public ESMF_AttributeLink
      public ESMF_AttributeLinkRemove
      public ESMF_AttributeSet
      public ESMF_AttributeUpdate
      public ESMF_AttributeRead
      public ESMF_AttributeWrite

!EOPI 
!------------------------------------------------------------------------------
! leave the following line as-is; it will insert the cvs ident string
! into the object file for tracking purposes.
      character(*), parameter, private :: version = &
               '$Id: ESMF_Attribute.cppF90,v 1.56.2.1 2010/02/05 20:03:28 svasquez Exp $'
!------------------------------------------------------------------------------
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeAdd  - Create Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeAdd
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttAddPackCstm
        module procedure ESMF_ArrayAttAddPackStd
        module procedure ESMF_ArrayBundleAttAddPackCstm
        module procedure ESMF_ArrayBundleAttAddPackStd
        module procedure ESMF_CplCompAttAddPackStd
        module procedure ESMF_CplCompAttAddPackCstm
        module procedure ESMF_GridCompAttAddPackStd
        module procedure ESMF_GridCompAttAddPackCstm
        module procedure ESMF_DistGridAttAddPackCstm
        module procedure ESMF_FieldAttAddPackStd
        module procedure ESMF_FieldAttAddPackCstm
        module procedure ESMF_FieldBundleAttAddPackCstm
        module procedure ESMF_GridAttAddPackStd
        module procedure ESMF_GridAttAddPackCstm
        module procedure ESMF_StateAttAddPackStd
        module procedure ESMF_StateAttAddPackCstm
        
! !DESCRIPTION:
!     This interface provides a single entry point for methods that create
!     an Attribute package.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeCopy  - Copy an Attribute or hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeCopy
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttCopy
        module procedure ESMF_GridCompAttCopy
        module procedure ESMF_StateAttCopy
        
! !DESCRIPTION:
!     This interface provides a single entry point for methods that copy
!     an Attribute or Attribute hierarchy.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRemove  - Remove an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRemove
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttRemove
        module procedure ESMF_ArrayBundleAttRemove
        module procedure ESMF_CplCompAttRemove
        module procedure ESMF_GridCompAttRemove
        module procedure ESMF_DistGridAttRemove
        module procedure ESMF_FieldAttRemove
        module procedure ESMF_FieldBundleAttRemove
        module procedure ESMF_GridAttRemove
        module procedure ESMF_StateAttRemove

! !DESCRIPTION:
!     This interface provides a single entry point for methods that destroy
!     an Attribute or Attribute package.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGet  - Get Attributes, Attribute packages, count, 
!              info, and type
!
! !INTERFACE:
      interface ESMF_AttributeGet
   
! !PRIVATE MEMBER FUNCTIONS:
        TypeKindInterfaceMacro(ESMF_ArrayAttGet)
	TypeKindInterfaceMacro(ESMF_ArrayAttGet1D)
        module procedure ESMF_ArrayAttGetLgcl
        module procedure ESMF_ArrayAttGetLgclList
        module procedure ESMF_ArrayAttGetChar
        module procedure ESMF_ArrayAttGetCharList
        module procedure ESMF_ArrayAttGetInfoByNam
        module procedure ESMF_ArrayAttGetInfoByNum
        module procedure ESMF_ArrayAttGetCount

        TypeKindInterfaceMacro(ESMF_ArrayBundleAttGet)
	TypeKindInterfaceMacro(ESMF_ArrayBundleAttGet1D)
        module procedure ESMF_ArrayBundleAttGetLgcl
        module procedure ESMF_ArrayBundleAttGetLgclList
        module procedure ESMF_ArrayBundleAttGetChar
        module procedure ESMF_ArrayBundleAttGetCharList
        module procedure ESMF_ArrayBundleAttGetInfoByNam
        module procedure ESMF_ArrayBundleAttGetInfoByNum
        module procedure ESMF_ArrayBundleAttGetCount

        TypeKindInterfaceMacro(ESMF_CplCompAttGet)
	TypeKindInterfaceMacro(ESMF_CplCompAttGet1D)
        module procedure ESMF_CplCompAttGetLgcl
        module procedure ESMF_CplCompAttGetLgclList
        module procedure ESMF_CplCompAttGetChar
        module procedure ESMF_CplCompAttGetCharList
        module procedure ESMF_CplCompAttGetInfoByNam
        module procedure ESMF_CplCompAttGetInfoByNum
        module procedure ESMF_CplCompAttGetCount

        TypeKindInterfaceMacro(ESMF_GridCompAttGet)
	TypeKindInterfaceMacro(ESMF_GridCompAttGet1D)
        module procedure ESMF_GridCompAttGetLgcl
        module procedure ESMF_GridCompAttGetLgclList
        module procedure ESMF_GridCompAttGetChar
        module procedure ESMF_GridCompAttGetCharList
        module procedure ESMF_GridCompAttGetInfoByNam
        module procedure ESMF_GridCompAttGetInfoByNum
        module procedure ESMF_GridCompAttGetCount

        TypeKindInterfaceMacro(ESMF_DistGridAttGet)
	TypeKindInterfaceMacro(ESMF_DistGridAttGet1D)
        module procedure ESMF_DistGridAttGetLgcl
        module procedure ESMF_DistGridAttGetLgclList
        module procedure ESMF_DistGridAttGetChar
        module procedure ESMF_DistGridAttGetCharList
        module procedure ESMF_DistGridAttGetInfoByNam
        module procedure ESMF_DistGridAttGetInfoByNum
        module procedure ESMF_DistGridAttGetCount

        TypeKindInterfaceMacro(ESMF_FieldAttGet)
	TypeKindInterfaceMacro(ESMF_FieldAttGet1D)
        module procedure ESMF_FieldAttGetLgcl
        module procedure ESMF_FieldAttGetLgclList
        module procedure ESMF_FieldAttGetChar
        module procedure ESMF_FieldAttGetCharList
        module procedure ESMF_FieldAttGetInfoByNam
        module procedure ESMF_FieldAttGetInfoByNum
        module procedure ESMF_FieldAttGetCount

        TypeKindInterfaceMacro(ESMF_FieldBundleAttGet)
	TypeKindInterfaceMacro(ESMF_FieldBundleAttGet1D)
        module procedure ESMF_FieldBundleAttGetLgcl
        module procedure ESMF_FieldBundleAttGetLgclList
        module procedure ESMF_FieldBundleAttGetChar
        module procedure ESMF_FieldBundleAttGetCharList
        module procedure ESMF_FieldBundleAttGetInfoByNam
        module procedure ESMF_FieldBundleAttGetInfoByNum
        module procedure ESMF_FieldBundleAttGetCount

        TypeKindInterfaceMacro(ESMF_GridAttGet)
	TypeKindInterfaceMacro(ESMF_GridAttGet1D)
        module procedure ESMF_GridAttGetLgcl
        module procedure ESMF_GridAttGetLgclList
        module procedure ESMF_GridAttGetChar
        module procedure ESMF_GridAttGetCharList
        module procedure ESMF_GridAttGetInfoByNam
        module procedure ESMF_GridAttGetInfoByNum
        module procedure ESMF_GridAttGetCount

        TypeKindInterfaceMacro(ESMF_StateAttGet)
	TypeKindInterfaceMacro(ESMF_StateAttGet1D)
        module procedure ESMF_StateAttGetLgcl
        module procedure ESMF_StateAttGetLgclList
        module procedure ESMF_StateAttGetChar
        module procedure ESMF_StateAttGetCharList
        module procedure ESMF_StateAttGetInfoByNam
        module procedure ESMF_StateAttGetInfoByNum
        module procedure ESMF_StateAttGetCount

! !DESCRIPTION:
!     This interface provides a single entry point for methods that retrieve
!     Attributes.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLink  - Link Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLink
   
! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_ArrayBundleAttLinkArray
        module procedure ESMF_CplCompAttLinkCplComp
        module procedure ESMF_CplCompAttLinkGridComp
        module procedure ESMF_CplCompAttLinkState
        module procedure ESMF_FieldBundleAttLinkField
        module procedure ESMF_FieldBundleAttLinkGrid
        module procedure ESMF_FieldAttLinkGrid
        module procedure ESMF_GridCompAttLinkCplComp
        module procedure ESMF_GridCompAttLinkGridComp
        module procedure ESMF_GridCompAttLinkState
        module procedure ESMF_StateAttLinkArrayBundle
        module procedure ESMF_StateAttLinkArray
        module procedure ESMF_StateAttLinkFieldBundle
        module procedure ESMF_StateAttLinkField
        module procedure ESMF_StateAttLinkState

! !DESCRIPTION:
!     This interface provides a single entry point for methods that link
!     Attribute hierarchies.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLinkRemove  - Unlink Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLinkRemove
   
! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_ArrayBundleAttLinkRmArray
        module procedure ESMF_CplCompAttLinkRmCplComp
        module procedure ESMF_CplCompAttLinkRmGridComp
        module procedure ESMF_CplCompAttLinkRmState
        module procedure ESMF_FieldBundleAttLinkRmField
        module procedure ESMF_FieldBundleAttLinkRmGrid
        module procedure ESMF_FieldAttLinkRmGrid
        module procedure ESMF_GridCompAttLinkRmCplComp
        module procedure ESMF_GridCompAttLinkRmGridComp
        module procedure ESMF_GridCompAttLinkRmState
        module procedure ESMF_StateAttLinkRmArrayBundle
        module procedure ESMF_StateAttLinkRmArray
        module procedure ESMF_StateAttLinkRmFieldBundle
        module procedure ESMF_StateAttLinkRmField
        module procedure ESMF_StateAttLinkRmState

! !DESCRIPTION:
!     This interface provides a single entry point for methods that unlink
!     Attribute hierarchies.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRead  - Read an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRead
   
! !PRIVATE MEMBER FUNCTIONS:
! TODO
!        module procedure ESMF_ArrayAttRead
!        module procedure ESMF_ArrayBundleAttRead
        module procedure ESMF_CplCompAttRead
        module procedure ESMF_GridCompAttRead
!        module procedure ESMF_DistGridAttRead
        module procedure ESMF_FieldAttRead
        module procedure ESMF_FieldBundleAttRead
        module procedure ESMF_GridAttRead
        module procedure ESMF_StateAttRead

! !DESCRIPTION:
!     This interface provides a single entry point for methods that read
!     an Attribute or Attribute package.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeSet  - Set Attributes and Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeSet 
   
! !PRIVATE MEMBER FUNCTIONS:
	TypeKindInterfaceMacro(ESMF_ArrayAttSet)
	TypeKindInterfaceMacro(ESMF_ArrayAttSet1D)
        module procedure ESMF_ArrayAttSetLgcl
        module procedure ESMF_ArrayAttSetLgclList
        module procedure ESMF_ArrayAttSetChar
        module procedure ESMF_ArrayAttSetCharList

	TypeKindInterfaceMacro(ESMF_ArrayBundleAttSet)
	TypeKindInterfaceMacro(ESMF_ArrayBundleAttSet1D)
        module procedure ESMF_ArrayBundleAttSetLgcl
        module procedure ESMF_ArrayBundleAttSetLgclList
        module procedure ESMF_ArrayBundleAttSetChar
        module procedure ESMF_ArrayBundleAttSetCharList

	TypeKindInterfaceMacro(ESMF_CplCompAttSet)
	TypeKindInterfaceMacro(ESMF_CplCompAttSet1D)
        module procedure ESMF_CplCompAttSetLgcl
        module procedure ESMF_CplCompAttSetLgclList
        module procedure ESMF_CplCompAttSetChar
        module procedure ESMF_CplCompAttSetCharList

	TypeKindInterfaceMacro(ESMF_GridCompAttSet)
	TypeKindInterfaceMacro(ESMF_GridCompAttSet1D)
        module procedure ESMF_GridCompAttSetLgcl
        module procedure ESMF_GridCompAttSetLgclList
        module procedure ESMF_GridCompAttSetChar
        module procedure ESMF_GridCompAttSetCharList

	TypeKindInterfaceMacro(ESMF_DistGridAttSet)
	TypeKindInterfaceMacro(ESMF_DistGridAttSet1D)
        module procedure ESMF_DistGridAttSetLgcl
        module procedure ESMF_DistGridAttSetLgclList
        module procedure ESMF_DistGridAttSetChar
        module procedure ESMF_DistGridAttSetCharList

	TypeKindInterfaceMacro(ESMF_FieldAttSet)
	TypeKindInterfaceMacro(ESMF_FieldAttSet1D)
        module procedure ESMF_FieldAttSetLgcl
        module procedure ESMF_FieldAttSetLgclList
        module procedure ESMF_FieldAttSetChar
        module procedure ESMF_FieldAttSetCharList

	TypeKindInterfaceMacro(ESMF_FieldBundleAttSet)
	TypeKindInterfaceMacro(ESMF_FieldBundleAttSet1D)
        module procedure ESMF_FieldBundleAttSetLgcl
        module procedure ESMF_FieldBundleAttSetLgclList
        module procedure ESMF_FieldBundleAttSetChar
        module procedure ESMF_FieldBundleAttSetCharList

	TypeKindInterfaceMacro(ESMF_GridAttSet)
	TypeKindInterfaceMacro(ESMF_GridAttSet1D)
        module procedure ESMF_GridAttSetLgcl
        module procedure ESMF_GridAttSetLgclList
        module procedure ESMF_GridAttSetChar
        module procedure ESMF_GridAttSetCharList

	TypeKindInterfaceMacro(ESMF_StateAttSet)
	TypeKindInterfaceMacro(ESMF_StateAttSet1D)
        module procedure ESMF_StateAttSetLgcl
        module procedure ESMF_StateAttSetLgclList
        module procedure ESMF_StateAttSetChar
        module procedure ESMF_StateAttSetCharList

! !DESCRIPTION:
!     This interface provides a single entry point for methods that attach
!     Attributes and Attribute packages, and link Attribute hierarchies.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeWrite  - Write an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeWrite
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttWrite
        module procedure ESMF_ArrayBundleAttWrite
        module procedure ESMF_CplCompAttWrite
        module procedure ESMF_GridCompAttWrite
        !module procedure ESMF_DistGridAttWrite
        module procedure ESMF_FieldAttWrite
        module procedure ESMF_FieldBundleAttWrite
        !module procedure ESMF_GridAttWrite
        module procedure ESMF_StateAttWrite

! !DESCRIPTION:
!     This interface provides a single entry point for methods that write
!     an Attribute or Attribute package.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeUpdate  - Update an Attribute hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeUpdate
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttUpdate
        module procedure ESMF_GridCompAttUpdate
        module procedure ESMF_FieldAttUpdate
        module procedure ESMF_FieldBundleAttUpdate
        module procedure ESMF_StateAttUpdate

! !DESCRIPTION:
!     This interface provides a single entry point for methods that update
!     an Attribute hierarchy.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add an ESMF standard Attribute package
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd() 
!     subroutine ESMF_AttAddPackStandard(<object>, convention, purpose, nestConvention, &
!                                nestPurpose, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: convention
!     character (len = *), intent(in) :: purpose
!     character (len = *), intent(in), optional :: nestConvention
!     character (len = *), intent(in), optional :: nestPurpose
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Add an ESMF standard Attribute package.  See Section~\ref{desc:AttPacks}
!     for a description of Attribute packages and their conventions, purposes,
!     and object types.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [convention]
!           The convention of the new Attribute package
!     \item [purpose]
!           The purpose of the new Attribute package
!     \item [{[nestConvention]}]
!           The convention of the Attribute package around which to nest the
!           new Attribute package
!     \item [{[nestPurpose]}]
!           The purpose of the Attribute package around which to nest the
!           new Attribute package
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add a custom Attribute package or modify an existing Attribute package
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd() 
!     subroutine ESMF_AttAddPackCstm(<object>, convention, purpose, &
!     attrList, count, nestConvention, nestPurpose, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     character (len=*), dimension(:), intent(in) :: attrList
!     integer, intent(in), optional :: count   
!     character (len = *), intent(in), optional :: nestConvention
!     character (len = *), intent(in), optional :: nestPurpose
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Add a custom Attribute package to <object>.  
!     See Section~\ref{desc:AttPacks} for a description of Attribute packages
!     and their conventions, purposes, and object types.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_DistGrid), intent(inout) :: distgrid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [convention]
!           The convention of the Attribute package
!     \item [purpose]
!           The purpose of the Attribute package
!     \item [attrList]
!           The list of Attribute names to specify the custom Attribute package
!     \item [{[count]}]
!           The number of Attributes to add to the custom Attribute package
!     \item [{[nestConvention]}]
!           The convention of the Attribute package around which to nest the
!           new Attribute package
!     \item [{[nestPurpose]}]
!           The purpose of the Attribute package around which to nest the
!           new Attribute package
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeCopy() 
!     subroutine ESMF_AttributeCopy(<object1>, <object2>, attcopyflag, atttreeflag, rc)
!
! !ARGUMENTS:
!     <object1>, see below for supported values  
!     <object2>, see below for supported values 
!     type(ESMF_AttCopyFlag), intent(in) :: attcopyflag
!     type(ESMF_AttTreeFlag), intent(in) :: atttreeflag
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Copy an Attribute hierarchy from <object1> to <object2>.  
!     Supported values for <object1> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: comp1  
!     \item type(ESMF\_GridComp), intent(inout) :: comp1 
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for <object2> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: comp2  
!     \item type(ESMF\_GridComp), intent(inout) :: comp2 
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     NOTE: Copies between different ESMF objects are not possible at this time.
! 
!     The arguments are:
!     \begin{description}
!     \item [<object1>]
!           An {\tt ESMF} object
!     \item [<object2>]
!           An {\tt ESMF} object
!     \item [attcopyflag]
!           A flag to determine if the copy is to be by reference, value,
!           or both
!     \item [atttreeflag]
!           A flag to determine if the copy is supposed to descend the 
!           Attribute hierarchy
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!     NOTE:  Not all combinations of copy flags are enabled at this time.  See
!            the reference manual for an overview of the options available for 
!            {\tt ESMF\_AttributeCopy()}.
!            The options for {\tt attcopyflag} include:
!            \begin{enumerate}
!              \item ESMF\_ATTCOPY\_HYBRID will copy the top base level
!		     Attributes by value, and all others by reference
!              \item ESMF\_ATTCOPY\_REFERENCE will copy all Attributes by reference
!              \item ESMF\_ATTCOPY\_VALUE will copy all Attributes by value
!            \end{enumerate}
!            The options for {\tt atttreeflag} include:
!            \begin{enumerate}
!              \item ESMF\_ATTTREE\_OFF will only descend the first base level 
!                    of the Attribute hierarchy
!              \item ESMF\_ATTTREE\_ON will descend the entire Attribute hierarchy
!            \end{enumerate}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet  - Get an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeGet(<object>, name, <value argument>, &
!                            <defaultvalue argument>, convention, purpose, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     <value argument>, see below for supported values
!     <defaultvalue argument>, see below for supported values   
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Return an Attribute value from the <object>, or from the Attribute package
!     specified by {\tt convention} and {\tt purpose}.  A default value 
!     argument may be given if a return code is not desired when the 
!     Attribute is not found.  See Section~\ref{desc:AttPacks} for a
!     description of Attribute packages and their conventions, purposes,
!     and object types.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_DistGrid), intent(inout) :: distgrid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for <value argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(out) :: value
!     \item integer(ESMF\_KIND\_I8), intent(out) :: value
!     \item real (ESMF\_KIND\_R4), intent(out) :: value
!     \item real (ESMF\_KIND\_R8), intent(out) :: value
!     \item logical, intent(out) :: value
!     \item character (len = *), intent(out), value
!     \end{description}
!     Supported values for <defaultvalue argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(out), optional :: defaultvalue
!     \item integer(ESMF\_KIND\_I8), intent(out), optional :: defaultvalue
!     \item real (ESMF\_KIND\_R4), intent(out), optional :: defaultvalue
!     \item real (ESMF\_KIND\_R8), intent(out), optional :: defaultvalue
!     \item logical, intent(out), optional :: defaultvalue
!     \item character (len = *), intent(out), optional :: defaultvalue
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to retrieve
!     \item [<value argument>]
!           The value of the named Attribute
!     \item [{[<defaultvalue argument>]}]
!           The default value of the named Attribute
!     \item [{[convention]}]
!           The convention of the Attribute package
!     \item [{[purpose]}]
!           The purpose of the Attribute package
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet  - Get an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeGet(<object>, name, <valueList argument>, &
!                            <defaultvalueList argument>, convention, purpose, &
!                            itemCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     <valueList argument>, see below for supported values
!     <defaultvalueList argument>, see below for supported values   
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(inout), optional :: itemCount
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Return an Attribute value from the <object>, or from the Attribute package
!     specified by {\tt convention} and {\tt purpose}.  A default value 
!     argument may be given if a return code is not desired when the 
!     Attribute is not found.  See Section~\ref{desc:AttPacks} for a
!     description of Attribute packages and their conventions, purposes,
!     and object types.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_DistGrid), intent(inout) :: distgrid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for <value argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), dimension(:), intent(out) :: valueList
!     \item integer(ESMF\_KIND\_I8), dimension(:), intent(out) :: valueList
!     \item real (ESMF\_KIND\_R4), dimension(:), intent(out) :: valueList
!     \item real (ESMF\_KIND\_R8), dimension(:), intent(out) :: valueList
!     \item logical, dimension(:), intent(out) :: valueList
!     \item character (len = *), dimension(count), intent(out) :: valueList
!     \end{description}
!     Supported values for <defaultvalue argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), dimension(:), intent(out), optional :: defaultvalueList
!     \item integer(ESMF\_KIND\_I8), dimension(:), intent(out), optional :: defaultvalueList
!     \item real (ESMF\_KIND\_R4), dimension(:), intent(out), optional :: defaultvalueList
!     \item real (ESMF\_KIND\_R8), dimension(:), intent(out), optional :: defaultvalueList
!     \item logical, dimension(:), intent(out), optional :: defaultvalueList
!     \item character (len = *), dimension(:), intent(out), optional :: defaultvalueList
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to retrieve
!     \item [<valueList argument>]
!           The valueList of the named Attribute
!     \item [{[<defaultvalueList argument>]}]
!           The default value list of the named Attribute
!     \item [{[convention]}]
!           The convention of the Attribute package
!     \item [{[purpose]}]
!           The purpose of the Attribute package
!     \item [{[itemCount]}]
!           The number of items in a multi-valued Attribute.  If the itemCount is passed in, only itemCount
!           items of the desired Attribute will be returned, as long as there is enough space and there are 
!           itemCount items to return.  Regardless of whether itemCount is passed in, it will be returned as the
!           number of items that was {\it actually} returned.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get the Attribute count
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet() 
!     subroutine ESMF_AttributeGetCount(<object>, count, attcountflag, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     integer, intent(out) :: count
!     type(ESMF_AttCountFlag), intent(in), optional :: attcountflag
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Return the Attribute count for <object>.  
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_DistGrid), intent(inout) :: distgrid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [count] 
!           The Attribute count for <object>
!     \item [{[attcountflag]}]
!           The flag to specify which attribute count to return, the 
!           default is ESMF\_ATTGETCOUNT\_ATTRIBUTE (see below)
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!     NOTE:  The options for {\tt attcountflag} include:
!            \begin{enumerate}
!              \item ESMF\_ATTGETCOUNT\_ATTRIBUTE will get the number of single Attributes
!              \item ESMF\_ATTGETCOUNT\_ATTPACK will get the number of Attribute packages
!              \item ESMF\_ATTGETCOUNT\_ATTLINK will get the number of Attribute links
!              \item ESMF\_ATTGETCOUNT\_TOTAL will get the total number of Attributes
!            \end{enumerate}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by name
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet() 
!     subroutine ESMF_AttributeGetInfoByNam(<object>, name, typekind, itemCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     type(ESMF_TypeKind), intent(out), optional :: typekind
!     integer, intent(out), optional :: itemCount   
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Return information associated with the named Attribute, 
!     including {\tt typekind} and {\tt itemCount}.  
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_DistGrid), intent(inout) :: distgrid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to query
!     \item [{[typekind}]]
!           The typekind of the Attribute
!     \item [{[itemCount]}]
!           The number of items in this Attribute
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by index number
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet() 
!     subroutine ESMF_AttributeGetInfoByNum(<object>, attributeIndex, name, &
!       typekind, itemcount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     integer, intent(in) :: attributeIndex
!     character (len = *), intent(out) :: name
!     type(ESMF_TypeKind), intent(out), optional :: typekind
!     integer, intent(out), optional :: itemCount   
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Returns information associated with the indexed Attribute, 
!     including {\tt name}, {\tt typekind} and {\tt itemCount}.  Keep in
!     mind that these indexes start from 1, as expected in a Fortran API.
!     Supported values for <object> are:  
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_DistGrid), intent(inout) :: distgrid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [attributeIndex]
!           The index number of the Attribute to query
!     \item [name]
!           The name of the Attribute
!     \item [{[typekind]}]
!           The typekind of the Attribute
!     \item [{[itemCount]}]
!           The number of items in this Attribute
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a Component Attribute hierarchy to that of a Component or State
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLink()
!      subroutine ESMF_CompAttLink(<object1>, <object2>, rc)
!
! !ARGUMENTS:
!      <object1>, see below for supported values  
!      <object2>, see below for supported values
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Attach a {\tt CplComp} or {\tt GridComp} Attribute hierarchy to the 
!     hierarchy of a {\tt CplComp}, {\tt GridComp}, or {\tt State}.  
!     Supported values for the <object1> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: comp1
!     \item type(ESMF\_GridComp), intent(inout) :: comp1
!     \end{description}
!     Supported values for the <object2> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: comp2
!     \item type(ESMF\_GridComp), intent(inout) :: comp2
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object1>]
!       The ``parent'' object in the Attribute hierarchy link
!     \item [<object2>]
!       The ``child'' object in the Attribute hierarchy link
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a State Attribute hierarchy with the 
! hierarchy of a an Array, ArrayBundle, Field, FieldBundle, or State
! 
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLink()
!      subroutine ESMF_StateAttLink(state, <object>, rc)
!
! !ARGUMENTS:
!      type(ESMF\_State), intent(inout) :: state  
!      <object>, see below for supported values
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Attach a {\tt State} Attribute hierarchy to the hierarchy of
!     a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}.  
!     Supported values for the <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_Field), intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [state]
!       An {\tt ESMF\_State} object
!     \item [<object>]
!       The object with which to link hierarchies
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a FieldBundle and Field Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLink()
!      subroutine ESMF_FieldBundleAttLink(fieldbundle, field, rc)
!
! !ARGUMENTS:
!      type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!      type(ESMF\_Field), intent(inout) :: field
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Attach a {\tt FieldBundle} Attribute hierarchy to the hierarchy of
!     a {\tt Field}.  
!
!     The arguments are:
!     \begin{description}
!     \item [fieldbundle]
!       An {\tt ESMF\_FieldBundle} object
!     \item [field]
!       An {\tt ESMF\_Field} object
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a Field and Grid Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLink()
!      subroutine ESMF_FieldAttLink(field, grid, rc)
!
! !ARGUMENTS:
!      type(ESMF\_Field), intent(inout) :: field
!      type(ESMF\_Grid), intent(inout) :: grid
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Attach a {\tt Field} Attribute hierarchy to the hierarchy of
!     a {\tt Grid}. 
! 
!     The arguments are:
!     \begin{description}
!     \item [field]
!       An {\tt ESMF\_Field} object
!     \item [grid]
!       An {\tt ESMF\_Grid} object
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link an ArrayBundle and Array Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLink()
!      subroutine ESMF_ArrayBundleAttLink(arraybundle, array, rc)
!
! !ARGUMENTS:
!      type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!      type(ESMF\_Array), intent(inout) :: array
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Attach an {\tt ArrayBundle} Attribute hierarchy to the hierarchy of
!     an {\tt Array}.  
!
!     The arguments are:
!     \begin{description}
!     \item [arraybundle]
!       An {\tt ESMF\_ArrayBundle} object
!     \item [array]
!       An {\tt ESMF\_Array} object
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a Component Attribute hierarchy from that of a Component or State
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLinkRemove()
!      subroutine ESMF_CompAttLinkRemove(<object1>, <object2>, rc)
!
! !ARGUMENTS:
!      <object1>, see below for supported values  
!      <object2>, see below for supported values
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Unattach a {\tt CplComp} or {\tt GridComp} Attribute hierarchy from the 
!     hierarchy of a {\tt CplComp}, {\tt GridComp}, or {\tt State}.  
!     Supported values for the <object1> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: comp1
!     \item type(ESMF\_GridComp), intent(inout) :: comp1
!     \end{description}
!     Supported values for the <object2> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: comp2
!     \item type(ESMF\_GridComp), intent(inout) :: comp2
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object1>]
!       The ``parent'' object in the Attribute hierarchy link
!     \item [<object2>]
!       The ``child'' object in the Attribute hierarchy link
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a State Attribute hierarchy with 
! the hierarchy of an Array, ArrayBundle, Field, FieldBundle, or State
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLinkRemove()
!      subroutine ESMF_StateAttLinkRemove(state, <object>, rc)
!
! !ARGUMENTS:
!      type(ESMF\_State), intent(inout) :: state  
!      <object>, see below for supported values
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Unattach a {\tt State} Attribute hierarchy from the hierarchy of
!     a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}.  
!     Supported values for the <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_Field), intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [state]
!       An {\tt ESMF\_State} object
!     \item [<object>]
!       The object with which to unlink hierarchies
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a FieldBundle and Field Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLinkRemove()
!      subroutine ESMF_FieldBundleAttLinkRemove(fieldbundle, field, rc)
!
! !ARGUMENTS:
!      type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!      type(ESMF\_Field), intent(inout) :: field
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Unattach a {\tt FieldBundle} Attribute hierarchy from the hierarchy of
!     a {\tt Field}.  
! 
!     The arguments are:
!     \begin{description}
!     \item [fieldbundle]
!       An {\tt ESMF\_FieldBundle} object
!     \item [field]
!       An {\tt ESMF\_Field} object
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a Field and Grid Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLinkRemove()
!      subroutine ESMF_FieldAttLinkRemove(field, grid, rc)
!
! !ARGUMENTS:
!      type(ESMF\_Field), intent(inout) :: field
!      type(ESMF\_Grid), intent(inout) :: grid
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Unattach a {\tt Field} Attribute hierarchy from the hierarchy of
!     a {\tt Grid}. 
! 
!     The arguments are:
!     \begin{description}
!     \item [field]
!       An {\tt ESMF\_Field} object
!     \item [grid]
!       An {\tt ESMF\_Grid} object
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink an ArrayBundle and Array Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLinkRemove()
!      subroutine ESMF_ArrayBundleAttLinkRemove(arraybundle, array, rc)
!
! !ARGUMENTS:
!      type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!      type(ESMF\_Array), intent(inout) :: array
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Unattach an {\tt ArrayBundle} Attribute hierarchy from the hierarchy of
!     an {\tt Array}.  
! 
!     The arguments are:
!     \begin{description}
!     \item [arraybundle]
!       An {\tt ESMF\_ArrayBundle} object
!     \item [array]
!       An {\tt ESMF\_Array} object
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRead  - Read Attributes from an XML file
!
! !INTERFACE:
!     subroutine ESMF_AttributeRead(<object>, fileName, convention, purpose, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len=*),   intent(in), optional :: fileName
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(out), optional :: rc
!
! !DESCRIPTION:
!     Read Attributes for <object>.  If present, the convention and purpose
!     specify an Attribute package which is used to filter the reading to just
!     those attributes belonging to the Attribute package.  The file format
!     is XML.  See Section~\ref{desc:AttPacks} for a description of Attribute
!     packages and their conventions, purposes, and object types.
!
!     Requires the third party Xerces C++ XML Parser library to be installed.
!     For more details, see the "ESMF Users Guide",
!     "Building and Installing the ESMF, Third Party Libraries, Xerces" and
!     the website "http://xerces.apache.org/xerces-c".
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array             ! not yet implemented
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arrayBundle ! not yet implemented
!     \item type(ESMF\_CplComp), intent(inout) :: cplComp
!     \item type(ESMF\_GridComp), intent(inout) :: gridComp
!     \item type(ESMF\_Field), intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldBundle ! not yet implemented
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_DistGrid), intent(inout) :: distGrid       ! not yet implemented
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           The {\tt ESMF} object onto which the read Attributes will be placed
!     \item[{[fileName]}]
!           The name of the XML file to read
!     \item [{[convention]}]
!           The convention of the Attribute package to read
!     \item [{[purpose]}]
!           The purpose of the Attribute package to read
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute package
!
! !INTERFACE:
!     subroutine ESMF_AttributeRemove(<object>, name, convention, purpose, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in), optional :: name
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Remove an Attribute, or Attribute package on <object>.
!     See Section~\ref{desc:AttPacks} for a description of Attribute packages
!     and their conventions, purposes, and object types.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_DistGrid), intent(inout) :: distgrid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [{[name]}]
!           The name of the Attribute to remove
!     \item [{[convention]}]
!           The convention of the Attribute package
!     \item [{[purpose]}]
!           The purpose of the Attribute package
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!     NOTE:  An entire Attribute package can be removed by specifying 
!            {\tt convention} and {\tt purpose} only, without {\tt name}.  By specifying
!            {\tt convention}, {\tt purpose}, and {\tt name} an Attribute will be removed 
!            from the corresponding Attribute package, if it exists.  An 
!            Attribute can be removed directly from <object> by specifying
!            {\tt name}, without {\tt convention} and {\tt purpose}.
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeSet(<object>, name, <value argument>, &
!                                 convention, purpose, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     <value argument>, see below for supported values
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Attach an Attribute to <object>, or set an Attribute in an 
!     Attribute package.  The Attribute has a {\tt name} and either 
!     a {\tt value}, and a {\tt convention} and {\tt purpose}.  
!     See Section~\ref{desc:AttPacks} for a description of Attribute packages
!     and their conventions, purposes, and object types.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_DistGrid), intent(inout) :: distgrid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for the <value argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(in) :: value
!     \item integer(ESMF\_KIND\_I8), intent(in) :: value
!     \item real (ESMF\_KIND\_R4), intent(in) :: value
!     \item real (ESMF\_KIND\_R8), intent(in) :: value
!     \item logical, intent(in) :: value
!     \item character (len = *), intent(in), :: value
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to set
!     \item [<value argument>]
!           The value of the Attribute to set
!     \item [{[convention]}]
!           The convention of the Attribute package
!     \item [{[purpose]}]
!           The purpose of the Attribute package
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeSet(<object>, name, <valueList argument>, &
!                                 convention, purpose, itemCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     <valueList argument>, see below for supported values
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(in), optional :: itemCount
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Attach an Attribute to <object>, or set an Attribute in an 
!     Attribute package.  The Attribute has a {\tt name} and a 
!     {\tt valueList}, with an {\tt itemCount}, and a {\tt convention}
!     and {\tt purpose}.  See Section~\ref{desc:AttPacks} for a description
!     of Attribute packages and their conventions, purposes, and object types.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_DistGrid), intent(inout) :: distgrid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for the <value argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), dimension(:), intent(in) :: valueList
!     \item integer(ESMF\_KIND\_I8), dimension(:), intent(in) :: valueList
!     \item real (ESMF\_KIND\_R4), dimension(:), intent(in) :: valueList
!     \item real (ESMF\_KIND\_R8), dimension(:), intent(in) :: valueList
!     \item logical, dimension(:), intent(in) :: valueList
!     \item character (len = *), dimension(:), intent(in), :: valueList
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to set
!     \item [<valueList argument>]
!           The valueList of the Attribute to set
!     \item [{[convention]}]
!           The convention of the Attribute package
!     \item [{[purpose]}]
!           The purpose of the Attribute package
!     \item [{[itemCount]}]
!           The number of items in a multi-valued Attribute
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeUpdate  - Update an Attribute hierarchy
!
! !INTERFACE:
!     subroutine ESMF_AttributeUpdate(<object>, vm, rootList, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     type(ESMF_VM), intent(in) :: vm
!     integer, dimension(:), intent(in) :: rootList
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Update an Attribute hierarchy during runtime.  
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [vm]
!           The virtural machine over which this Attribute hierarchy 
!           should be updated
!     \item [rootList]
!           The list of ``root'' PETs that are to be used to update
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeWrite  - Write an Attribute package
!
! !INTERFACE:
!     subroutine ESMF_AttributeWrite(<object>, convention, purpose, attwriteflag, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Write the Attribute package for <object>.  The Attribute package defines 
!     the convention, purpose, and object type of the associated Attributes.  Either
!     tab-delimited or xml format is acheived by using {\tt attwriteflag}.  
!     See Section~\ref{desc:AttPacks} for a description of Attribute packages
!     and their conventions, purposes, and object types.
!
!     Note:  For an object type of {\tt ESMF\_GridComp}, convention='WaterML',
!     purpose='TimeSeries', and attwriteflag=ESMF\_ATTWRITE\_XML, an XML file
!     conforming to a hydrologic standard called WaterML will be written.  See
!     the following for more information:
!    
!     \begin{description}
!     \item{"http://his.cuahsi.org/wofws.html"}
!     \item{"http://www.earthsystemcurator.org/projects/waterml.shtml"}
!     \end{description}
!
!     An ESMF Use Test Case is available which showcases an example of how
!     to write a WaterML file; please see
!
!     \begin{description}
!     \item{"http://esmf.cvs.sourceforge.net/viewvc/esmf/use\_test\_cases/ESMF\_WaterML"}
!     \item{"http://esmf.cvs.sourceforge.net/viewvc/esmf/use\_test\_cases/README"}
!     \end{description}
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [{[convention]}]
!           The convention of the Attribute package
!     \item [{[purpose]}]
!           The purpose of the Attribute package
!     \item [{[attwriteflag]}]
!           The flag to specify which format is desired for the write, the 
!           default is tab-delimited
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!     NOTE:  The options for {\tt attwriteflag} include:
!            \begin{enumerate}
!              \item ESMF\_ATTWRITE\_XML will write in xml format
!              \item ESMF\_ATTWRITE\_TAB will write in tab-delimited format
!            \end{enumerate}
!
!EOP
!------------------------------------------------------------------------------


!-------------------------------------------------------------------------
!  Macro versions of the routines
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------

#define AttAddPackStandardMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttAddPackStandard" @\
 @\
!BOPI @\
! !IROUTINE: AttAddPackStandard - Add an ESMF standard Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeAdd() @\
      subroutine mclass##AttAddPackStd(mthis, convention, purpose, & @\
        nestConvention, nestPurpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character (len = *), intent(in) :: convention @\
      character (len = *), intent(in) :: purpose @\
      character (len = *), intent(in), optional :: nestConvention @\
      character (len = *), intent(in), optional :: nestPurpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Add an ESMF standard Attribute package @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An {\tt mclass} object. @\
!     \item [convention] @\
!      The convention of the new Attribute package. @\
!     \item [purpose] @\
!      The purpose of the new Attribute package. @\
!     \item [nestConvention] @\
!      The convention of the Attribute package around which to nest the @\
!      new Attribute package. @\
!     \item [nestPurpose] @\
!      The purpose of the Attribute package around which to nest the @\
!      new Attribute package. @\
!     \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
      type(ESMF_Logical) :: attpacknest @\
      character (len=*), parameter :: object=#mthis @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      attpacknest = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (convention .ne. "ESMF" .or. purpose .ne. "General") then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & @\
          "Convention must be ESMF, and purpose must be General for ESMF standard Attribute packages", & @\
          ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      if (present(nestConvention).or.present(nestPurpose)) then @\
        if (present(nestConvention).and..not.present(nestPurpose).or. & @\
            present(nestPurpose).and..not.present(nestConvention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both nestConvention and nestPurpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        else @\
          attpacknest = ESMF_TRUE; @\
        endif @\
      endif @\
 @\
      if (attpacknest == ESMF_FALSE) then @\
        call c_ESMC_AttPackCreateStandard(mthisfield, convention, & @\
          purpose, object, localrc) @\
      else @\
        call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
          "cannot nest an ESMF standard Attribute package onto a custom package", & @\
          ESMF_CONTEXT, rc) @\
        return @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttAddPackStd

!------------------------------------------------------------------------------

#define AttAddPackCustomMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttAddPackCstm" @\
!BOPI @\
! !IROUTINE: AttAddPackCstm - Add a custom Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeAdd() @\
      subroutine mclass##AttAddPackCstm(mthis, convention, purpose, & @\
      attrList, count, nestConvention, nestPurpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: convention @\
      character (len = *), intent(in) :: purpose @\
      character (len = *), dimension(:), intent(in) :: attrList @\
      integer, intent(in), optional :: count @\
      character (len = *), intent(in), optional :: nestConvention @\
      character (len = *), intent(in), optional :: nestPurpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Add a custom Attribute package for the object, or modify an  @\
!     existing Attribute package. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An ESMF object. @\
!     \item [convention] @\
!      The convention of the new Attribute package. @\
!     \item [purpose] @\
!      The purpose of the new Attribute package. @\
!     \item [attrList] @\
!      An array of character strings specifying the names of the user defined Attributes @\
!     \item [count] @\
!      The count of the number of Attributes to add to the package @\
!     \item [nestConvention] @\
!      The convention of the Attribute package around which to nest the @\
!      new Attribute package. @\
!     \item [nestPurpose] @\
!      The purpose of the Attribute package around which to nest the @\
!      new Attribute package. @\
!     \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, localCount @\
      character(len=*), parameter :: object=#mthis @\
      type(ESMF_Logical) :: attpacknest @\
@\
      ! Initialize return code; assume failure until success is certain @\
      attpacknest = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(count)) then @\
        if (count > size(attrList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & @\
            "count cannot be larger than size(attrList)", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
	localCount = count @\
      else @\
	localCount = size(attrList) @\
      end if @\
 @\
      if (localCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "attrList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      if (present(nestConvention).or.present(nestPurpose)) then @\
        if (present(nestConvention).and..not.present(nestPurpose).or. & @\
            present(nestPurpose).and..not.present(nestConvention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both nestConvention and nestPurpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        else @\
          attpacknest = ESMF_TRUE @\
        endif @\
      endif @\
 @\
      if (attpacknest == ESMF_FALSE) then @\
        call c_ESMC_AttPackCreateCustom(mthisfield, convention, & @\
          purpose, object, localrc) @\
      else @\
        call c_ESMC_AttPackNest(mthisfield, convention, & @\
          purpose, object, nestConvention, nestPurpose, localrc) @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      do i = 1, localCount @\
        call c_ESMC_AttPackAddAttribute(mthisfield, attrList(i), convention, & @\
            purpose, object, localrc) @\
      end do @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttAddPackCstm @\

!------------------------------------------------------------------------------ 

#define AttCopyMacro(mclass1, mclass2, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttributeCopy" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeCopy() @\
      subroutine mclass1##AttCopy(mthis1, mthis2, attcopyflag, atttreeflag, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(inout) :: mthis1   @\
      type(mclass2), intent(inout) :: mthis2 @\
      type(ESMF_AttCopyFlag), intent(in) :: attcopyflag @\
      type(ESMF_AttTreeFlag), intent(in) :: atttreeflag @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Copy all Attributes in one hierarchy to another. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!     \item [attcopyflag] @\
!      A flag to determine if the copy is to be by reference, value, or both @\
!     \item [atttreeflag] @\
!      A flag to determine if the copy is supposed to descend the Attribute @\
!      hierarchy @\
!     \item [{[rc]}] @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      call c_ESMC_AttributeCopy(mthisfield1, mthisfield2, & @\
                                attcopyflag, atttreeflag, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttCopy @\

!------------------------------------------------------------------------------

#define AttGetDoc() \
!BOPI @\
!EOPI @\

#define AttGetMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
@\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGet" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGet##mtypekind(mthis, name, value, defaultvalue, & @\
        convention, purpose, rc) @\
 @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), intent(out) :: value @\
      mtype(ESMF_KIND_##mtypekind), intent(inout), optional :: defaultvalue @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The real value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The real default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
@\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag, attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      present_flag = ESMF_FALSE @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
          fobject, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_##mtypekind, 1, value, & @\
            convention, purpose, fobject, localrc) @\
        endif @\
      else @\
       @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_##mtypekind, 1, value, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if(present_flag .ne. ESMF_TRUE) then @\
      if(present(defaultvalue)) then @\
        value = defaultvalue @\
      else  @\
        call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & @\
                    "Attribute not found, and no default given", & @\
                     ESMF_CONTEXT, rc) @\
        return @\
      endif @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGet##mtypekind @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGet1D" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGet1D##mtypekind(mthis, name, valueList, & @\
        defaultvalueList, convention, purpose, itemCount, rc) @\
 @\
      type(mclass), intent(inout) :: mthis   @\
      character (len=*), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(out) :: valueList @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(inout), optional :: defaultvalueList @\
      character (len=*), intent(in), optional :: convention @\
      character (len=*), intent(in), optional :: purpose @\
      integer, intent(inout), optional :: itemCount    @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The real value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The real default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, litemCount, i @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag, attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      present_flag = ESMF_FALSE @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
            "itemCount cannot be larger than size(valueList)", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
	      litemCount = itemCount @\
      else @\
	      litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
          fobject, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
        call c_ESMC_AttPackGetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
          convention, purpose, fobject, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
           ESMF_TYPEKIND_##mtypekind, litemCount, valueList, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if(present_flag .ne. ESMF_TRUE) then @\
      if(present(defaultvalueList)) then @\
        if(size(valueList) .lt. size(defaultvalueList)) then @\
          do i=1,size(valueList) @\
            valueList(i) = defaultvalueList(i) @\
          enddo @\
        else @\
          do i=1,size(defaultvalueList) @\
            valueList(i) = defaultvalueList(i) @\
          enddo @\
        endif @\
      else  @\
        call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & @\
                    "Attribute not found, and no default given", & @\
                     ESMF_CONTEXT, rc) @\
        return @\
      endif @\
      endif @\
 @\
      if (present(itemCount)) then @\
        itemCount = litemCount @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGet1D##mtypekind @\

!------------------------------------------------------------------------------

#define AttGetLogicalMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetLgcl" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetLgcl(mthis, name, value, defaultvalue, & @\
        convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, intent(out) :: value @\
      logical, intent(inout), optional :: defaultvalue @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a logical Attribute from the {\tt array}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The logical value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The logical default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: localvalue, present_flag, attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      present_flag = ESMF_FALSE @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
          fobject, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
            convention, purpose, fobject, localrc) @\
          if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          value = localvalue   @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) @\
          if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          value = localvalue @\
        endif @\
      endif @\
 @\
      if(present_flag .ne. ESMF_TRUE) then @\
      if(present(defaultvalue)) then @\
        value = defaultvalue @\
      else  @\
        call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & @\
                    "Attribute not found, and no default given", & @\
                     ESMF_CONTEXT, rc) @\
        return @\
      endif @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetLgcl @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetLgclList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetLgclList(mthis, name, valueList, & @\
        defaultvalueList, convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len=*), intent(in) :: name @\
      logical, dimension(:), intent(out) :: valueList @\
      logical, dimension(:), intent(inout), optional :: defaultvalueList @\
      character (len=*), intent(in), optional :: convention @\
      character (len=*), intent(in), optional :: purpose @\
      integer, intent(inout), optional :: itemCount    @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a logical list Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The logical values of the named Attribute. @\
!     \item [defaultvalueList] @\
!           The logical default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The number of values in the Attribute. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, litemCount, i @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag, attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      present_flag = ESMF_FALSE @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      	litemCount = itemCount @\
      else @\
	      litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
          fobject, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
            convention, purpose, fobject, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if(present_flag .ne. ESMF_TRUE) then @\
      if(present(defaultvalueList)) then @\
        if(size(valueList) .lt. size(defaultvalueList)) then @\
          do i=1,size(valueList) @\
            valueList(i) = defaultvalueList(i) @\
          enddo @\
        else @\
          do i=1,size(defaultvalueList) @\
            valueList(i) = defaultvalueList(i) @\
          enddo @\
        endif @\
      else  @\
        call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & @\
                    "Attribute not found, and no default given", & @\
                     ESMF_CONTEXT, rc) @\
        return @\
      endif @\
      endif @\
@\
    if (present(itemCount)) then @\
      itemCount = litemCount @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetLgclList @\

!------------------------------------------------------------------------------

#define AttGetCharacterMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetChar" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetChar(mthis, name, value, defaultvalue, & @\
        convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len = *), intent(out) :: value @\
      character (len = *), intent(inout), optional :: defaultvalue @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a character Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The character value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The character default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag, attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      present_flag = ESMF_FALSE @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
          fobject, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetChar(mthisfield, name, value, & @\
            convention, purpose, fobject, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetChar(mthisfield, name, value, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if(present_flag .ne. ESMF_TRUE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & @\
                    "Attribute not found, and no default given", & @\
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
      if (present(rc)) rc = localrc @\
 @\
      end subroutine mclass##AttGetChar @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetCharList" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetCharList(mthis, name, valueList, & @\
        defaultvalueList, convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len=*), dimension(:), intent(out) :: valueList @\
      character (len=*), dimension(:), intent(in), optional :: defaultvalueList @\
      character (len=*), intent(in), optional :: convention @\
      character (len=*), intent(in), optional :: purpose @\
      integer, intent(inout), optional :: itemCount @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a character Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The character list values of the named Attribute. @\
!     \item [defaultvalueList] @\
!           The character list default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The itemCount of the character items to retrieve @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, litemCount @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag, attpack @\
      integer, dimension(size(valueList)) :: lens @\
      character(len=(size(valueList)*len(valueList))) :: valueString @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      present_flag = ESMF_FALSE @\
      attpack = ESMF_FALSE @\
     if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      	litemCount = itemCount @\
      else @\
	      litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      do  i=1,litemCount @\
        lens(i) = len (valueList) @\
      enddo @\
       @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
          fobject, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
            litemCount, lens, valueString, convention, purpose, fobject, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present_flag == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
            litemCount, lens, valueString, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if(present_flag .ne. ESMF_TRUE) then @\
      if(present(defaultvalueList)) then @\
        if(size(valueList) .lt. size(defaultvalueList)) then @\
          do i=1,size(valueList) @\
            valueList(i) = defaultvalueList(i) @\
          enddo @\
        else @\
          do i=1,size(defaultvalueList) @\
            valueList(i) = defaultvalueList(i) @\
          enddo @\
        endif @\
      else  @\
        call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & @\
                    "Attribute not found, and no default given", & @\
                     ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      else @\
 @\
      j = 1 @\
      do  i=1,litemCount @\
        valueList(i) = valueString(j:(j+lens(i)-1)) @\
        j = j + lens(i) @\
      enddo @\
 @\
    if (present(itemCount)) then @\
      itemCount = litemCount @\
    endif @\
 @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetCharList @\

!------------------------------------------------------------------------------

#define GetCountNameNumberMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetCount" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet()  @\
      subroutine mclass##AttGetCount(mthis, count, attcountflag, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      integer, intent(out) :: count    @\
      type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Returns the number of Attributes associated with the given object  @\
!     in the argument {\tt count}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [count] @\
!           The number of Attributes associated with this object. @\
!     \item [attcountflag] @\
!           Flag to determine which Attribute count to return. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc  @\
      type(ESMF_AttGetCountFlag) :: lattcountflag @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(attcountflag)) then @\
        lattcountflag = attcountflag @\
      else @\
        lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE @\
      endif @\
 @\
      call c_ESMC_AttributeGetCount(mthisfield, count, lattcountflag, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetCount @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetInfoByNam" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetInfoByNam(mthis, name, typekind, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character(len=*), intent(in) :: name @\
      type(ESMF_TypeKind), intent(out), optional :: typekind @\
      integer, intent(out), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Returns information associated with the named Attribute,  @\
!     including {\tt typekind} and {\tt itemCount}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to query. @\
!     \item [{[typekind]}] @\
!           The typekind of the Attribute. @\
!     \item [{[itemCount]}] @\
!           The number of items in this Attribute.  For character types, @\
!           the length of the character string. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc              @\
      type(ESMF_TypeKind) :: localTk @\
      integer :: litemCount @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call c_ESMC_AttributeGetInfoName(mthisfield, name, & @\
        localTk, litemCount, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(typekind)) typekind = localTk @\
      if (present(itemCount)) itemCount = litemCount @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetInfoByNam @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetInfoByNum" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetInfoByNum(mthis, attributeIndex, name, & @\
        typekind, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      integer, intent(in) :: attributeIndex @\
      character(len=*), intent(out) :: name @\
      type(ESMF_TypeKind), intent(out), optional :: typekind @\
      integer, intent(out), optional :: itemCount @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns information associated with the indexed Attribute,  @\
!      including {\tt name}, {\tt typekind} and {\tt itemCount}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [attributeIndex] @\
!           The index number of the Attribute to query. @\
!     \item [name] @\
!           Returns the name of the Attribute. @\
!     \item [{[typekind]}] @\
!           The typekind of the Attribute. @\
!     \item [{[itemCount]}] @\
!           Returns the number of items in this Attribute.  For character types, @\
!           this is the length of the character string. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc  @\
      character(len=len(name)) :: localName @\
      type(ESMF_TypeKind) :: localTk @\
      integer :: litemCount @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call c_ESMC_AttributeGetInfoNum(mthisfield, attributeIndex, & @\
        localName, localTk, litemCount, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      name = localName @\
      if (present(typekind)) typekind = localTk @\
      if (present(itemCount)) itemCount = litemCount @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetInfoByNum @\
 @\
      
!-----------------------------------------------------------------------------

#define AttLinkMacro(mclass1, mclass2, mclass2short, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttLink" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLink() @\
      subroutine mclass1##AttLink##mclass2short(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(inout) :: mthis1 @\
      type(mclass2), intent(inout)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      call c_ESMC_AttributeLink(mthisfield1, mthisfield2, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttLink##mclass2short @\

!-----------------------------------------------------------------------------

#define ESMF_StateAttLinkMacro(mclass, mclassshort, mthis1, mthis2, mthisfield1, mthisfield2, mthisfield3, mobj) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_StateAttLink" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLink() @\
      subroutine ESMF_StateAttLink##mclassshort(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(ESMF_State), intent(inout) :: mthis1 @\
      type(mclass), intent(inout)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt ESMF\_State} object. @\
!     \item [mthis2] @\
!      An {\tt mclass} object. @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
      type(ESMF_Logical) :: lvalue1, lvalue2 @\
      character (len=*), parameter :: lobject = #mobj @\
      character (len=*), parameter :: lname1 = 'import' @\
      character (len=*), parameter :: lname2 = 'export' @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,mthis1,rc) @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis2,rc) @\
 @\
      call c_ESMC_AttributeLink(mthisfield1, mthisfield2, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      ! set the import and export Attributes on any Field connected to this State @\
      lvalue1 = .true. @\
      lvalue2 = .false. @\
      if (mthis1%mthisfield3 == ESMF_STATE_IMPORT) then @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname1, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname2, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) @\
      else if (mthis1%mthisfield3 == ESMF_STATE_EXPORT) then @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname1, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname2, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine ESMF_StateAttLink##mclassshort @\

!-----------------------------------------------------------------------------

#define AttLinkRemoveMacro(mclass1, mclass2, mclass2short, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttLinkRemove" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLinkRemove() @\
      subroutine mclass1##AttLinkRm##mclass2short(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(inout) :: mthis1 @\
      type(mclass2), intent(inout)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Unattaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      call c_ESMC_AttributeLinkRemove(mthisfield1, mthisfield2, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttLinkRm##mclass2short @\

!-----------------------------------------------------------------------------

#define AttReadMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttRead" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeRead() @\
      subroutine mclass##AttRead(mthis, fileName, convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character (len=*),   intent(in), optional :: fileName @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Read the Attribute package for the {\tt mthis}. @\
!     The Attribute package defines the convention, purpose, and object type @\
!     of the associated Attributes. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An {\tt mclass} object. @\
!     \item[{[fileName]}] @\
!      The file name to be read from. @\
!     \item [convention] @\
!      The convention of the Attribute package. @\
!     \item [purpose] @\
!      The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      ! initialize fileName length to zero for non-existent name @\
      integer :: fileNameLen, localrc @\
 @\
      fileNameLen = 0 @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
      localrc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS @\
      !TODO: Remove the following dummy test when dummy argument actually used @\
      if (convention == convention .and. purpose==purpose) continue @\
 @\
      ! get length of given fileName for C++ validation @\
      if (present(fileName)) then @\
        fileNameLen = len_trim(fileName) @\
      end if @\
 @\
      ! invoke C to C++ entry point @\
      ! TODO: convention, purpose @\
      call c_ESMC_AttributeRead(mthisfield, fileNameLen, fileName, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttRead @\

!------------------------------------------------------------------------------

#define AttRemoveMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttRemove" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeRemove  - Remove an Attribute or Attribute Package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeRemove() @\
      subroutine mclass##AttRemove(mthis, name, convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in), optional :: name @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
! @\
! !DESCRIPTION: @\
!     Removes an Attribute on the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to destroy. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE .and. .not.present(name)) then @\
        call c_ESMC_AttPackRemove(mthisfield, convention, & @\
          purpose, fobject, localrc) @\
      else if (attpack == ESMF_TRUE .and. present(name)) then @\
        call c_ESMC_AttPackRemoveAttribute(mthisfield, name, convention, & @\
          purpose, fobject, localrc) @\
      else if (present(name)) then @\
        call c_ESMC_AttributeRemove(mthisfield, name, localrc) @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttRemove @\

!------------------------------------------------------------------------------

#define AttSetDoc() \
!BOPI @\
!EOPI @\

#define AttSetMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
 @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSet" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSet##mtypekind(mthis, name, value, convention, & @\
        purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), intent(in) :: value @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach an Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The integer value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc  @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_##mtypekind, 1, value, & @\
          convention, purpose, fobject, localrc) @\
      else @\
        call c_ESMC_AttributeSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_##mtypekind, 1, value, localrc) @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSet##mtypekind @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSet1D" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSet1D##mtypekind(mthis, name, valueList, & @\
        convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(in) :: valueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach an Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt valueList}. @\
!     The number of integer items in the {\tt valueList} is @\
!     given by {\tt itemCount}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [valueList] @\
!           The integer values of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The number of integers in the {\tt valueList}. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
@\
      integer :: localrc, litemCount @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      	litemCount = itemCount @\
      else @\
      	litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
          convention, purpose, fobject, localrc) @\
      else @\
        call c_ESMC_AttributeSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_##mtypekind, litemCount, valueList, localrc) @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSet1D##mtypekind @\

!------------------------------------------------------------------------------

#define AttSetLogicalMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetLgcl" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetLgcl(mthis, name, value, convention, & @\
        purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, intent(in) :: value @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach a logical Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The logical true/false value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: localvalue @\
      type(ESMF_Logical) :: attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      localvalue = value @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
          convention, purpose, fobject, localrc) @\
      else @\
        call c_ESMC_AttributeSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetLgcl @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetLgclList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetLgclList(mthis, name, valueList, & @\
        convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, dimension(:), intent(in) :: valueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach a logical list Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt valueList}. @\
!     The number of logical items in the {\tt valueList} is @\
!     given by {\tt itemCount}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The logical true/false values of the Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The number of logicals in the {\tt valueList}. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, litemCount @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      	litemCount = itemCount @\
      else @\
      	litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
          convention, purpose, fobject, localrc) @\
      else @\
        call c_ESMC_AttributeSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetLgclList @\

!------------------------------------------------------------------------------

#define AttSetCharacterMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetChar" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetChar(mthis, name, value, convention, & @\
        purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len = *), intent(in) :: value @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach a character Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The character value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: attpack @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackSetChar(mthisfield, name, value, & @\
          ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) @\
      else @\
        call c_ESMC_AttributeSetChar(mthisfield, name, value, localrc) @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetChar @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetCharList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetCharList(mthis, name, valueList, & @\
        convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character(len=*), intent(in) :: name @\
      character (len = *), dimension(:), intent(in) :: valueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: itemCount @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach a character Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The character value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, litemCount @\
      character(len=*), parameter :: fobject=#mthis @\
      integer, dimension(size(valueList)) :: lens @\
      character(len=(size(valueList)*len(valueList))) :: valueString @\
      type(ESMF_Logical) :: attpack @\
@\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      	litemCount = itemCount @\
      else @\
	      litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      j = 1 @\
      do  i=1,litemCount @\
        lens(i) = len_trim(valueList(i)) @\
        valueString(j:(j+lens(i)-1)) = valueList(i) @\
        j = j + lens(i) @\
      enddo @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
          litemCount, valueString, lens, convention, purpose, fobject, localrc) @\
      else @\
        call c_ESMC_AttributeSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
          litemCount, valueString, lens, localrc) @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetCharList @\

!-----------------------------------------------------------------------------

#define AttUpdateMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttUpdate" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeUpdate() @\
      subroutine mclass##AttUpdate(mthis, vm, rootList, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      type(ESMF_VM), intent(in) :: vm @\
      integer, dimension(:), intent(in) :: rootList @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Update an Attribute hierarchy. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An {\tt mclass} object. @\
!     \item [vm] @\
!      The virtural machine over which this Attribute hierarchy  @\
!      should be updated. @\
!     \item [rootList] @\
!      The list of "root" PETs that are to be used to update. @\
!     \item [{[rc]}]  @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, count                           ! Error status @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      count = size(rootList) @\
      call c_ESMC_AttributeUpdate(mthisfield, vm, rootList, count, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttUpdate @\

!-----------------------------------------------------------------------------

#define AttWriteMacro(mclass, mthis, mthisfield, mthisobj, mthistar) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttWrite" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file @\
 @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeWrite() @\
      subroutine mclass##AttWrite(mthis, convention, purpose, attwriteflag, rc) @\
 @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Write the Attribute package for the {\tt state}. @\
!     The Attribute package defines the convention, purpose, and object type  @\
!     of the associated Attributes. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [state] @\
!      An {\tt ESMF\_State} object. @\
!     \item [convention] @\
!      The convention of the Attribute package. @\
!     \item [purpose] @\
!      The purpose of the Attribute package. @\
!     \item [attwriteflag] @\
!      Flag to determine the format for writing the Attributes. @\
!     \item [{[rc]}]  @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthisobj @\
      character(len=*), parameter :: ftarobj=#mthistar @\
      type(ESMF_AttWriteFlag) :: writeflag @\
      type(ESMF_Logical) :: attpack @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & @\
            "both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (present(attwriteflag)) then @\
        writeflag = attwriteflag @\
      else @\
        writeflag = ESMF_ATTWRITE_TAB @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then @\
          call c_ESMC_AttributeWriteTab(mthisfield, convention, & @\
            purpose, fobject, ftarobj, localrc) @\
        else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then @\
          call c_ESMC_AttributeWriteXML(mthisfield, convention, & @\
            purpose, fobject, ftarobj, localrc) @\
      	endif @\
      endif @\
      if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttWrite @\

!-------------------------------------------------------------------------
!  ARRAY
!-------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_Array, array, array)
AttAddPackStandardMacro(ESMF_Array, array, array)
AttRemoveMacro(ESMF_Array, array, array)

TypeKind3DeclarationMacro(AttGet, ESMF_Array, array, array)
AttGetLogicalMacro(ESMF_Array, array, array)
AttGetCharacterMacro(ESMF_Array, array, array)

GetCountNameNumberMacro(ESMF_Array, array, array)      

TypeKind3DeclarationMacro(AttSet, ESMF_Array, array, array)
AttSetLogicalMacro(ESMF_Array, array, array)
AttSetCharacterMacro(ESMF_Array, array, array)

AttUpdateMacro(ESMF_Array, array, array)
AttWriteMacro(ESMF_Array, array, array, array, array)

!-------------------------------------------------------------------------
!  ARRAYBUNDLE
!-------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttAddPackStandardMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttRemoveMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

TypeKind3DeclarationMacro(AttGet, ESMF_ArrayBundle, arraybundle, arraybundle)
AttGetLogicalMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttGetCharacterMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

GetCountNameNumberMacro(ESMF_ArrayBundle, arraybundle, arraybundle)      

AttLinkMacro(ESMF_ArrayBundle, ESMF_Array, Array, arraybundle, array, & @\
                arraybundle, array)
AttLinkRemoveMacro(ESMF_ArrayBundle, ESMF_Array, Array, arraybundle, array, & @\
                arraybundle, array)

TypeKind3DeclarationMacro(AttSet, ESMF_ArrayBundle, arraybundle, arraybundle)
AttSetLogicalMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttSetCharacterMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

AttUpdateMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttWriteMacro(ESMF_ArrayBundle, arraybundle, arraybundle, arraybundle, array)

!-------------------------------------------------------------------------
!  CplComp
!-------------------------------------------------------------------------

AttAddPackStandardMacro(ESMF_CplComp, comp, comp%compp%base)
AttAddPackCustomMacro(ESMF_CplComp, comp, comp%compp%base)
AttCopyMacro(ESMF_CplComp, ESMF_CplComp, comp1, comp2, comp1%compp%base, comp2%compp%base)

TypeKind3DeclarationMacro(AttGet, ESMF_CplComp, comp, comp%compp%base)
AttGetLogicalMacro(ESMF_CplComp, comp, comp%compp%base)
AttGetCharacterMacro(ESMF_CplComp, comp, comp%compp%base)

GetCountNameNumberMacro(ESMF_CplComp, comp, comp%compp%base)

AttLinkMacro(ESMF_CplComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkMacro(ESMF_CplComp, ESMF_GridComp, GridComp, comp1, comp2,  & @\
                comp1%compp%base, comp2%compp%base)
AttLinkMacro(ESMF_CplComp, ESMF_State, State, comp, state,  & @\
                comp%compp%base, state%statep%base)
AttLinkRemoveMacro(ESMF_CplComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveMacro(ESMF_CplComp, ESMF_GridComp, GridComp, comp1, comp2,  & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveMacro(ESMF_CplComp, ESMF_State, State, comp, state,  & @\
                comp%compp%base, state%statep%base)

AttReadMacro(ESMF_CplComp, comp, comp%compp%base)

AttRemoveMacro(ESMF_CplComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttSet, ESMF_CplComp, comp, comp%compp%base)
AttSetLogicalMacro(ESMF_CplComp, comp, comp%compp%base)
AttSetCharacterMacro(ESMF_CplComp, comp, comp%compp%base)

AttUpdateMacro(ESMF_CplComp, comp, comp%compp%base)
AttWriteMacro(ESMF_CplComp, comp, comp%compp%base, comp, field)

!-------------------------------------------------------------------------
!  GridComp
!-------------------------------------------------------------------------

AttAddPackStandardMacro(ESMF_GridComp, comp, comp%compp%base)
AttAddPackCustomMacro(ESMF_GridComp, comp, comp%compp%base)
AttCopyMacro(ESMF_GridComp, ESMF_GridComp, comp1, comp2, comp1%compp%base, comp2%compp%base)
AttRemoveMacro(ESMF_GridComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttGet, ESMF_GridComp, comp, comp%compp%base)
AttGetLogicalMacro(ESMF_GridComp, comp, comp%compp%base)
AttGetCharacterMacro(ESMF_GridComp, comp, comp%compp%base)

GetCountNameNumberMacro(ESMF_GridComp, comp, comp%compp%base)

AttLinkMacro(ESMF_GridComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkMacro(ESMF_GridComp, ESMF_GridComp, GridComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkMacro(ESMF_GridComp, ESMF_State, State, comp, state, & @\
                comp%compp%base, state%statep%base)
AttLinkRemoveMacro(ESMF_GridComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveMacro(ESMF_GridComp, ESMF_GridComp, GridComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveMacro(ESMF_GridComp, ESMF_State, State, comp, state, & @\
                comp%compp%base, state%statep%base)

AttReadMacro(ESMF_GridComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttSet, ESMF_GridComp, comp, comp%compp%base)
AttSetLogicalMacro(ESMF_GridComp, comp, comp%compp%base)
AttSetCharacterMacro(ESMF_GridComp, comp, comp%compp%base)

AttUpdateMacro(ESMF_GridComp, comp, comp%compp%base)
AttWriteMacro(ESMF_GridComp, comp, comp%compp%base, comp, field)

!-------------------------------------------------------------------------
!  DISTGRID
!-------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_DistGrid, distgrid, distgrid)

TypeKind3DeclarationMacro(AttGet, ESMF_DistGrid, distgrid, distgrid)
AttGetLogicalMacro(ESMF_DistGrid, distgrid, distgrid)
AttGetCharacterMacro(ESMF_DistGrid, distgrid, distgrid)

GetCountNameNumberMacro(ESMF_DistGrid, distgrid, distgrid)      

AttRemoveMacro(ESMF_DistGrid, distgrid, distgrid)

TypeKind3DeclarationMacro(AttSet, ESMF_DistGrid, distgrid, distgrid)
AttSetLogicalMacro(ESMF_DistGrid, distgrid, distgrid)
AttSetCharacterMacro(ESMF_DistGrid, distgrid, distgrid)

!-------------------------------------------------------------------------
!  FIELD
!-------------------------------------------------------------------------

AttAddPackStandardMacro(ESMF_Field, field, field%ftypep%base)
AttAddPackCustomMacro(ESMF_Field, field, field%ftypep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_Field, field, field%ftypep%base)
AttGetLogicalMacro(ESMF_Field, field, field%ftypep%base)
AttGetCharacterMacro(ESMF_Field, field, field%ftypep%base)

GetCountNameNumberMacro(ESMF_Field, field, field%ftypep%base)

AttLinkMacro(ESMF_Field, ESMF_Grid, Grid, field, grid, & @\
                field%ftypep%base, grid)
AttLinkRemoveMacro(ESMF_Field, ESMF_Grid, Grid, field, grid, & @\
                field%ftypep%base, grid)

AttReadMacro(ESMF_Field, field, field%ftypep%base)

AttRemoveMacro(ESMF_Field, field, field%ftypep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_Field, field, field%ftypep%base)
AttSetLogicalMacro(ESMF_Field, field, field%ftypep%base)
AttSetCharacterMacro(ESMF_Field, field, field%ftypep%base)

AttUpdateMacro(ESMF_Field, field, field%ftypep%base)
AttWriteMacro(ESMF_Field, field, field%ftypep%base, field, field)

!-------------------------------------------------------------------------
!  FIELDBUNDLE
!-------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttGetLogicalMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttGetCharacterMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

GetCountNameNumberMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

AttLinkMacro(ESMF_FieldBundle, ESMF_Field, Field, fieldbundle, field, & @\
                fieldbundle%btypep%base, field%ftypep%base)
AttLinkMacro(ESMF_FieldBundle, ESMF_Grid, Grid, fieldbundle, grid, & @\
                fieldbundle%btypep%base, grid)
AttLinkRemoveMacro(ESMF_FieldBundle, ESMF_Field, Field, fieldbundle, field, & @\
                fieldbundle%btypep%base, field%ftypep%base)
AttLinkRemoveMacro(ESMF_FieldBundle, ESMF_Grid, Grid, fieldbundle, grid, & @\
                fieldbundle%btypep%base, grid)

AttReadMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

AttRemoveMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttSetLogicalMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttSetCharacterMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

AttUpdateMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttWriteMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base, fieldbundle, field)

!-------------------------------------------------------------------------
!  GRID
!-------------------------------------------------------------------------

AttAddPackStandardMacro(ESMF_Grid, grid, grid)
AttAddPackCustomMacro(ESMF_Grid, grid, grid)

TypeKind3DeclarationMacro(AttGet, ESMF_Grid, grid, grid)
AttGetLogicalMacro(ESMF_Grid, grid, grid)
AttGetCharacterMacro(ESMF_Grid, grid, grid)

GetCountNameNumberMacro(ESMF_Grid, grid, grid)

AttReadMacro(ESMF_Grid, grid, grid)

AttRemoveMacro(ESMF_Grid, grid, grid)

TypeKind3DeclarationMacro(AttSet, ESMF_Grid, grid, grid)
AttSetLogicalMacro(ESMF_Grid, grid, grid)
AttSetCharacterMacro(ESMF_Grid, grid, grid)

!-------------------------------------------------------------------------
!  STATE
!-------------------------------------------------------------------------

AttAddPackStandardMacro(ESMF_State, state, state%statep%base)
AttAddPackCustomMacro(ESMF_State, state, state%statep%base)
AttCopyMacro(ESMF_State, ESMF_State, state1, state2, state1%statep%base, state2%statep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_State, state, state%statep%base)
AttGetLogicalMacro(ESMF_State, state, state%statep%base)
AttGetCharacterMacro(ESMF_State, state, state%statep%base)

GetCountNameNumberMacro(ESMF_State, state, state%statep%base)

ESMF_StateAttLinkMacro(ESMF_Array, Array, state, array, state%statep%base, & @\
                          array, statep%st, array)
ESMF_StateAttLinkMacro(ESMF_ArrayBundle, ArrayBundle, state, arraybundle, state%statep%base, & @\
                          arraybundle, statep%st, array)
ESMF_StateAttLinkMacro(ESMF_Field, Field, state, field, state%statep%base, & @\
                          field%ftypep%base, statep%st, field)
ESMF_StateAttLinkMacro(ESMF_FieldBundle, FieldBundle, state, fieldbundle, state%statep%base, & @\
                          fieldbundle%btypep%base, statep%st, field)
ESMF_StateAttLinkMacro(ESMF_State, State, state1, state2, state1%statep%base, & @\
                          state2%statep%base, statep%st, field)
AttLinkRemoveMacro(ESMF_State, ESMF_Array, Array, state, array, & @\
                state%statep%base, array)
AttLinkRemoveMacro(ESMF_State, ESMF_ArrayBundle, ArrayBundle, state, arraybundle, & @\
                state%statep%base, arraybundle)
AttLinkRemoveMacro(ESMF_State, ESMF_Field, Field, state, field, & @\
                state%statep%base, field%ftypep%base)
AttLinkRemoveMacro(ESMF_State, ESMF_FieldBundle, FieldBundle, state, fieldbundle, & @\
                state%statep%base, fieldbundle%btypep%base)
AttLinkRemoveMacro(ESMF_State, ESMF_State, State, state1, state2, & @\
                state1%statep%base, state2%statep%base)

AttRemoveMacro(ESMF_State, state, state%statep%base)

AttReadMacro(ESMF_State, state, state%statep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_State, state, state%statep%base)
AttSetLogicalMacro(ESMF_State, state, state%statep%base)
AttSetCharacterMacro(ESMF_State, state, state%statep%base)

AttUpdateMacro(ESMF_State, state, state%statep%base)
AttWriteMacro(ESMF_State, state, state%statep%base, state, field)

!------------------------------------------------------------------------------

end module ESMF_AttributeMod
